# ============================================================================
# ACTION: Select Environment Secret
# ============================================================================
# PURPOSE:
# Resolves environment-specific secrets using naming conventions.
# Retrieves base64-encoded environment files from GitHub secrets.
#
# WHAT IT DOES:
# 1. Constructs secret name from prefix, env name, and suffix
# 2. Retrieves secret from GitHub Actions secrets
# 3. Returns secret value and metadata
# 4. Optionally fails if secret is missing
#
# WHEN TO USE:
# - Retrieve environment-specific secrets
# - Load environment files
# - Part of deployment pipeline
#
# NAMING CONVENTION:
# <prefix><UPPERCASE env_name><suffix>
# Example: PROD_ENV_B64, STAGING_ENV_B64, DEV_ENV_B64
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for complete guide
# ============================================================================

name: 'common: select-env-secret'
description: 'Resolve an environment-specific base64 secret using a naming convention (e.g., ENV_B64_PROD)'

# ============================================================================
# INPUTS
# ============================================================================
inputs:
  env_name:
    description: 'Environment name. Required. Example: prod, staging, dev'
    required: true
  secrets_json:
    description: "JSON string containing secrets (e.g., toJSON(secrets)). Used to lookup secrets without exposing them in global env."
    required: false
  secret_prefix:
    description: "Secret name prefix. Default: empty. Final secret: <prefix><UPPERCASE env_name><suffix>"
    required: false
    default: ''
  secret_suffix:
    description: "Secret name suffix. Default: _ENV_B64. Final secret: <prefix><UPPERCASE env_name><suffix>"
    required: false
    default: '_ENV_B64'
  required:
    description: 'Fail if secret is missing/empty. Default: false. Set true to require secret'
    required: false
    default: 'false'

# ============================================================================
# OUTPUTS
# ============================================================================
outputs:
  env_b64:
    description: 'Resolved base64-encoded secret value (may be empty when not required)'
    value: ${{ steps.resolve.outputs.env_b64 }}
  secret_name:
    description: 'Fully-qualified secret name that was queried'
    value: ${{ steps.resolve.outputs.secret_name }}
  found:
    description: "'true' when the secret existed and had a non-empty value"
    value: ${{ steps.resolve.outputs.found }}

runs:
  using: 'composite'
  steps:
    - name: Resolve environment secret
      id: resolve
      shell: bash
      env:
        SECRETS_JSON: ${{ inputs.secrets_json }}
        SECRET_PREFIX: ${{ inputs.secret_prefix }}
        SECRET_SUFFIX: ${{ inputs.secret_suffix }}
        ENV_NAME_RAW: ${{ inputs.env_name }}
        REQUIRED: ${{ inputs.required }}
      run: |
        set -euo pipefail

        env_name="${ENV_NAME_RAW}"
        if [ -z "${env_name}" ]; then
          echo 'Environment name is required.' >&2
          exit 1
        fi

        env_upper=$(echo "${env_name}" | tr '[:lower:]' '[:upper:]')

        prefix="${SECRET_PREFIX}"
        suffix="${SECRET_SUFFIX}"
        
        # Only apply default prefix if BOTH prefix and suffix are empty
        # This allows explicit suffix-only naming (e.g., PROD_ENV_B64 with prefix='' suffix='_ENV_B64')
        if [ -z "${prefix}" ] && [ -z "${suffix}" ]; then
          prefix='ENV_B64_'
        fi

        secret_name="${prefix}${env_upper}${suffix}"
        
        echo "ðŸ” Looking up secret: ${secret_name}"
        echo "   Prefix: '${prefix}'"
        echo "   Environment: ${env_name} (upper: ${env_upper})"
        echo "   Suffix: '${suffix}'"
        
        # Try to get secret from JSON input first
        secret_value=""
        if [ -n "${SECRETS_JSON}" ]; then
          echo "   Secrets JSON provided (length: ${#SECRETS_JSON} chars)"
          # Use jq to extract the secret safely
          # We escape the secret name to prevent injection/errors if it has weird chars (unlikely for env keys)
          if command -v jq >/dev/null 2>&1; then
             secret_value=$(echo "${SECRETS_JSON}" | jq -r --arg key "$secret_name" '.[$key] // empty')
             if [ -n "${secret_value}" ]; then
               echo "   âœ“ Found secret in secrets_json"
             fi
          else
             echo "::warning::jq not found, cannot parse secrets_json. Falling back to environment lookup."
          fi
        else
          echo "   No secrets_json provided, will use environment lookup"
        fi

        # Fallback to environment variable if not found in JSON
        if [ -z "${secret_value}" ]; then
          echo "   Checking environment variable: ${secret_name}"
          secret_value="$(printenv "${secret_name}" 2>/dev/null || true)"
          if [ -n "${secret_value}" ]; then
            echo "   âœ“ Found secret in environment variable"
          fi
        fi

        if [ -z "${secret_value}" ]; then
          if [ "${REQUIRED}" = "true" ]; then
            echo "::error::Secret ${secret_name} is not configured or empty." >&2
            exit 1
          fi
          found="false"
          echo "   âš  Secret not found (not required, continuing without it)"
        else
          echo "::add-mask::${secret_value}"
          found="true"
          echo "   âœ“ Secret resolved successfully (${#secret_value} chars)"
        fi

        printf 'env_b64=%s\n' "${secret_value}" >>"${GITHUB_OUTPUT}"
        printf 'secret_name=%s\n' "${secret_name}" >>"${GITHUB_OUTPUT}"
        printf 'found=%s\n' "${found}" >>"${GITHUB_OUTPUT}"
