# ============================================================================
# ACTION: Select Environment Secret
# ============================================================================
# PURPOSE:
# Resolves environment-specific secrets using naming conventions.
# Retrieves base64-encoded environment files from GitHub secrets.
#
# WHAT IT DOES:
# 1. Constructs secret name from prefix, env name, and suffix
# 2. Retrieves secret from GitHub Actions secrets
# 3. Returns secret value and metadata
# 4. Optionally fails if secret is missing
#
# WHEN TO USE:
# - Retrieve environment-specific secrets
# - Load environment files
# - Part of deployment pipeline
#
# NAMING CONVENTION:
# <prefix><UPPERCASE env_name><suffix>
# Example: PROD_ENV_B64, STAGING_ENV_B64, DEV_ENV_B64
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for complete guide
# ============================================================================

name: 'common: select-env-secret'
description: 'Resolve an environment-specific base64 secret using a naming convention (e.g., ENV_B64_PROD)'

# ============================================================================
# INPUTS
# ============================================================================
inputs:
  env_name:
    description: 'Environment name. Required. Example: prod, staging, dev'
    required: true
  secret_prefix:
    description: "Secret name prefix. Default: empty. Final secret: <prefix><UPPERCASE env_name><suffix>"
    required: false
    default: ''
  secret_suffix:
    description: "Secret name suffix. Default: _ENV_B64. Final secret: <prefix><UPPERCASE env_name><suffix>"
    required: false
    default: '_ENV_B64'
  required:
    description: 'Fail if secret is missing/empty. Default: false. Set true to require secret'
    required: false
    default: 'false'

# ============================================================================
# OUTPUTS
# ============================================================================
outputs:
  env_b64:
    description: 'Resolved base64-encoded secret value (may be empty when not required)'
    value: ${{ steps.resolve.outputs.env_b64 }}
  secret_name:
    description: 'Fully-qualified secret name that was queried'
    value: ${{ steps.resolve.outputs.secret_name }}
  found:
    description: "'true' when the secret existed and had a non-empty value"
    value: ${{ steps.resolve.outputs.found }}

runs:
  using: 'composite'
  steps:
    - name: Resolve environment secret
      id: resolve
      shell: bash
      env:
        SECRET_PREFIX: ${{ inputs.secret_prefix }}
        SECRET_SUFFIX: ${{ inputs.secret_suffix }}
        ENV_NAME_RAW: ${{ inputs.env_name }}
        REQUIRED: ${{ inputs.required }}
      run: |
        set -euo pipefail

        env_name="${ENV_NAME_RAW}"
        if [ -z "${env_name}" ]; then
          echo 'Environment name is required.' >&2
          exit 1
        fi

        env_upper=$(echo "${env_name}" | tr '[:lower:]' '[:upper:]')

        prefix="${SECRET_PREFIX}"
        suffix="${SECRET_SUFFIX}"
        if [ -z "${prefix}" ] && [ -z "${suffix}" ]; then
          prefix='ENV_B64_'
        fi

        secret_name="${prefix}${env_upper}${suffix}"
        secret_value="$(printenv "${secret_name}" 2>/dev/null || true)"

        if [ -z "${secret_value}" ]; then
          if [ "${REQUIRED}" = "true" ]; then
            echo "Error: Secret ${secret_name} is not configured or empty." >&2
            exit 1
          fi
          found="false"
        else
          echo "::add-mask::${secret_value}"
          found="true"
        fi

        printf 'env_b64=%s\n' "${secret_value}" >>"${GITHUB_OUTPUT}"
        printf 'secret_name=%s\n' "${secret_name}" >>"${GITHUB_OUTPUT}"
        printf 'found=%s\n' "${found}" >>"${GITHUB_OUTPUT}"
