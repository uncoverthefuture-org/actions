# ============================================================================
# ACTION: SSH Container Deploy
# ============================================================================
# PURPOSE:
# Deploys a generic containerized application to a remote server via SSH using
# Podman. Supports Traefik routing by default when a domain is provided and
# falls back to host port mapping when no domain is available.
#
# WHAT IT DOES:
# 1. Optionally prepares a fresh Ubuntu host (Podman, Traefik, directories)
# 2. Writes environment file to remote server
# 3. Logs in to container registry and pulls image
# 4. Starts container with Traefik labels or host port mapping
#
# WHEN TO USE:
# - Deploy any containerized app (web/API/etc.)
# - Supports production, staging, development
# - First-time host prep (prepare_host: true) or repeat deploys
# ============================================================================

name: 'SSH Container Deploy' # Action name as shown in logs/marketplace
description: 'Deploy a container via Podman over SSH with optional Traefik routing and/or port mapping.' # High-level summary

inputs: # All parameters accepted by this action
  # SSH / Remote
  ssh_host:
    description: 'SSH host (IP or DNS) of the remote server (example: deploy.example.com)'
    required: true
  ssh_user:
    description: 'SSH username used for remote execution (example: deploy)'
    required: true
  ssh_key:
    description: 'Private key for ssh_user (PEM). Provide via repository/organization secret.'
    required: true
  root_ssh_key:
    description: 'Optional private key for root for privileged operations (provide via secret)'
    required: false
  ssh_port:
    description: 'SSH port on remote host (default 22)'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Optional host key fingerprint for trust pinning (example: ssh-ed25519 AAAAC3Nza...)'
    required: false
  skip_upload:
    description: 'Skip staging/upload of deploy-container.sh (assumes scripts deployed via infra/deploy-server-scripts)'
    required: false
    default: 'true'
  ensure_scripts_deployed:
    description: 'Automatically deploy the server scripts bundle before any remote steps'
    required: false
    default: 'true'

  # Smart defaults
  default_host_port:
    description: 'Default host port when not using Traefik and no host_port provided'
    required: false
    default: '8080'
  default_container_port:
    description: 'Default container port when not provided'
    required: false
    # NOTE: Project standard default is 8080 (consistent across actions and scripts).
    # Example: if your app listens on 4000, set `container_port: '4000'` (or define
    # WEB_CONTAINER_PORT/TARGET_PORT/PORT in the remote .env) so labels map correctly.
    default: '8080'

  # Deployment directories
  deployment_base_dir:
    description: 'Base directory for deployments on remote server. Default: ~/deployments (user-writable, no sudo required)'
    required: false
    default: '~/deployments'

  # Auto env secret resolution (reads job env like PROD_ENV_B64/STAGING_ENV_B64/DEV_ENV_B64)
  auto_fetch_env:
    description: 'When true and env_b64 not provided, resolve from job env based on env_name'
    required: false
    default: 'true'
  secrets_json:
    description: "JSON string containing secrets (e.g., toJSON(secrets)). Used to lookup secrets without exposing them in global env."
    required: false
  enable_acme:
    description: 'When true (default), attach certresolver label for ACME; set false to skip Let''s Encrypt while debugging.'
    required: false
    default: 'true'
  traefik_reset_acme:
    description: "When 'true', reset Traefik ACME storage on the next run (clears acme.json so new certificates are requested)."
    required: false
    default: 'false'
  traefik_network_name:
    description: 'Podman network to connect service containers to when Traefik is enabled (default: traefik-network).'
    required: false
    default: 'traefik-network'
  traefik_use_host_network:
    description: 'Run Traefik on host network to avoid CNI DNS issues (true recommended).'
    required: false
    default: 'false'
  traefik_skip_upload:
    description: 'Skip uploading Traefik scripts (assumes scripts already installed on server).'
    required: false
    default: 'true'
  enable_dashboard:
    description: 'Enable Traefik dashboard exposure (paired with dashboard_publish_modes)'
    required: false
    default: 'true'
  dashboard_publish_modes:
    description: 'CSV of dashboard modes: http8080, https8080, subdomain, or both'
    required: false
    default: ''
  dashboard_host:
    description: 'FQDN for dashboard when using subdomain mode'
    required: false
    default: ''
  dashboard_password:
    description: 'Plain password for admin user (hashed on host). Use dashboard_users_b64 for pre-hashed.'
    required: false
    default: ''
  dashboard_users_b64:
    description: 'Base64-encoded htpasswd-style users file for dashboard auth. Overrides dashboard_password when set.'
    required: false
    default: ''
  dns_servers:
    description: 'Optional comma or space-separated DNS servers for Traefik container (passed as --dns).'
    required: false
    default: ''
  env_secret_prefix:
    description: 'Prefix for env secret env var name'
    required: false
    default: ''
  env_secret_suffix:
    description: 'Suffix for env secret env var name'
    required: false
    default: '_ENV_B64'

  # Host prep
  prepare_host:
    description: "When true, prepare a fresh Ubuntu host (install Podman, create directories, manage users)."
    required: false
    default: 'true'
  install_podman:
    description: "Install Podman during host preparation when not already available (example: true)."
    required: false
    default: 'true'
  create_podman_user:
    description: "Create the podman_user account during host prep when it does not exist (example: false)."
    required: false
    default: 'false'
  install_traefik:
    description: "Install or reconcile the Traefik reverse proxy during host preparation (example: true)."
    required: false
    default: 'true'
  traefik_email:
    description: "Email passed to Traefik's ACME integration for certificate registration (example: ops@example.com)."
    required: false
  env_dir_path:
    description: "Base directory on the host where environment files and app metadata are stored (example: /opt/uactions/envs)."
    required: false
  additional_packages:
    description: "Extra apt packages installed during host preparation (space separated, example: 'jq curl ca-certificates')."
    required: false
    default: 'jq curl ca-certificates'
  enable_podman_cleanup:
    description: 'When true, run a safe Podman storage cleanup after successful deploys to prevent overlay bloat (age-based prune of stopped containers and unused images).'
    required: false
    default: 'true'
  podman_cleanup_min_age_days:
    description: 'Minimum age in days before Podman containers/images become eligible for pruning. Default is 1 day for automatic cleanup. Change via this input or PODMAN_PRUNE_MIN_AGE_DAYS env variable.'
    required: false
    default: '1'
  podman_cleanup_keep_recent_images:
    description: 'Hint for how many recent images to keep per host. Currently used for logging alongside the age-based prune (example: 2).'
    required: false
    default: '2'
  podman_cleanup_aggressive:
    description: 'When true (default), aggressively prune ALL stopped containers and unused images immediately after deployment, not just old ones. This prevents storage accumulation between deployments.'
    required: false
    default: 'true'
  ufw_allow_ports:
    description: "Space-separated list of ports opened in UFW during host prep (example: '80 443')."
    required: false
    default: '80 443'
  install_webmin:
    description: 'Install Webmin during host prep/first-run (requires sudo).'
    required: false
    default: 'true'
  install_usermin:
    description: 'Install Usermin alongside Webmin when enabled (requires sudo).'
    required: false
    default: 'false'
  install_portainer:
    description: 'Install Portainer CE (container management UI) on the host as a Quadlet-managed service.'
    required: false
    default: 'true'
  portainer_https_port:
    description: 'Host HTTPS port for Portainer UI (default: 9443).'
    required: false
    default: '9443'
  portainer_domain:
    description: 'FQDN for Portainer behind Traefik (example: portainer.example.com). When set, Portainer is exposed via Traefik on 443 in addition to direct :9443 access.'
    required: false
    default: ''
  portainer_admin_auto_init:
    description: "When 'true' (default), auto-initialize the Portainer admin user via the HTTPS API on first install using either portainer_admin_password or the default '12345678'."
    required: false
    default: 'true'
  portainer_admin_username:
    description: 'Username for the Portainer admin account during auto-init (default: admin).'
    required: false
    default: 'admin'
  portainer_admin_password:
    description: "Initial password for the Portainer admin account during auto-init. When empty and portainer_admin_auto_init is true, a convenience default of '12345678' is used and a warning is emitted in logs; change it immediately in production."
    required: false
    default: ''
  show_root_install_hints:
    description: 'Show explicit manual install instructions when root privileges are required (fail-fast messaging)'
    required: false
    default: 'true'

  # Env file
  env_name:
    description: "Logical environment name (production, staging, development). Auto-derived when omitted."
    required: false
  auto_detect_env:
    description: "When true, derive env_name from branch or tag using compute-defaults (example: true)."
    required: false
    default: 'true'
  env_file_path:
    description: "Remote base path where the .env file should be written (example: /opt/uactions/envs/app.env)."
    required: false
  write_env_file:
    description: "When true, write env_b64 or env_content to the remote server before deployment (example: true)."
    required: false
    default: 'false'
  env_b64:
    description: "Base64-encoded .env payload to materialize on the host (example: a repository/organization secret)."
    required: false
  env_content:
    description: "Raw .env content for the host. Prefer env_b64 for secrets (example: 'KEY=value')."
    required: false

  # Registry & image
  registry:
    description: "Container registry hostname used for image pulls (example: ghcr.io)."
    required: false
    default: 'ghcr.io'
  image_name:
    description: "Repository and image path without tag (example: org/app)."
    required: false
  image_tag:
    description: "Image tag to deploy (example: v1.2.3 or production-abcdef). Lower priority than version."
    required: false
  version:
    description: "Explicit version/tag to deploy (overrides image_tag). Example: v1.2.3"
    required: false
  registry_username:
    description: "Registry username for authenticated pulls (example: CI user or bot account)."
    required: false
  registry_token:
    description: "Registry password or token with pull permissions (example: secret token stored in the repository/organization)."
    required: false
  registry_login:
    description: "Attempt Podman login before pulling when credentials exist (example: true)."
    required: false
    default: 'true'

  # Runtime
  app_slug:
    description: "Human-readable slug for the application; defaults from the repo name (example: checkout)."
    required: false
  container_name:
    description: "Container name override; defaults to <app_slug>-<env> (example: checkout-prod)."
    required: false
  host_port:
    description: "Host port to publish when Traefik is disabled (example: 8080)."
    required: false
  container_port:
    description: "Container service port used by Traefik labels or host port mapping (example: 3000)."
    required: false
  restart_policy:
    description: "Podman restart policy applied to the container (example: unless-stopped)."
    required: false
    default: 'unless-stopped'
  extra_run_args:
    description: "Additional flags appended to podman run, provided as a quoted string (example: '--cap-add NET_ADMIN')."
    required: false
  memory_limit:
    description: "Memory limit (and swap) applied to the container (example: 512m)."
    required: false
    default: '512m'
  cpu_limit:
    description: "CPU limit passed as --cpus to podman. Default: 0.5 (half a CPU)."
    required: false
    default: '0.5'

  quadlet_enabled:
    description: "When 'false', skip generating Quadlet .container units for the app (no systemd persistence). Default: true."
    required: false
    default: 'true'

  # Logging / Debugging
  debug:
    description: 'Enable verbose logging, including env paths and user info (default: false)'
    required: false
    default: 'false'

  # Summary & diagnostics verbosity
  summary_mode:
    description: 'Controls deployment summary: full|light|off. full runs diagnostics + whoami probe; light skips diagnostics; off skips summary.'
    required: false
    default: 'full'

  # Env sourcing for deployment
  source_env:
    description: "When true, source the remote .env before executing deployment scripts so exports are available (example: true)."
    required: false
    default: 'true'
  fail_if_env_missing:
    description: "If source_env=true, halt the deployment when the .env file cannot be sourced; set false to proceed without env exports (example: true)."
    required: false
    default: 'true'

  # Domain / Traefik
  enable_traefik:
    description: "When true, attach Traefik labels and network when a domain is provided (example: true)."
    required: false
    default: 'true'
  ensure_traefik:
    description: 'Run infra/setup-traefik to reconcile Traefik (probe-first fast-path). Set false to skip entirely.'
    required: false
    default: 'true'
  domain:
    description: "Explicit domain to route the deployment (example: api.example.com)."
    required: false
  base_domain:
    description: "Base apex domain used to compute per-environment hostnames (example: example.com)."
    required: false
  domain_prefix_prod:
    description: "Prefix to prepend for production environments when base_domain is used (example: '')."
    required: false
    default: ''
  domain_prefix_staging:
    description: "Prefix applied to the staging environment when base_domain is set (example: staging)."
    required: false
  domain_prefix_dev:
    description: "Prefix applied to the development environment when base_domain is set (example: dev)."
    required: false
  require_dns_match:
    description: "Reserved flag to gate changes behind DNS validation (example: true)."
    required: false
    default: 'true'
  domain_aliases:
    description: "Optional comma or space-separated aliases routed to the service (example: 'www.example.com api.example.com')."
    required: false
    default: ''
  include_www_alias:
    description: "When true and domain is set, also include www.<domain> as an alias (example: false)."
    required: false
    default: 'false'
  domain_hosts:
    description: 'CSV of hostnames to route (preferred). Overrides aliases when provided.'
    required: false
    default: ''
  probe_path:
    description: "Path used by Traefik probe to validate deployment readiness (example: /health)."
    required: false
    default: '/'

runs: # Composite action implementation
  using: 'composite'
  steps:
    - name: Compute derived defaults # Derive slug, env, domain, tags, etc.
      id: dfl
      uses: ./.github/actions/app/common/compute-defaults
      with:
        env_name: ${{ inputs.env_name }} # Optional explicit env
        auto_detect_env: ${{ inputs.auto_detect_env }} # Derive env from branch/tag when true
        domain: ${{ inputs.domain }} # Optional override FQDN
        base_domain: ${{ inputs.base_domain }} # Apex domain to compute FQDN
        domain_prefix_prod: ${{ inputs.domain_prefix_prod }} # Prod prefix
        domain_prefix_staging: ${{ inputs.domain_prefix_staging }} # Staging prefix
        domain_prefix_dev: ${{ inputs.domain_prefix_dev }} # Dev prefix

    - name: Probe SSH reachability # Fast pre-probe to avoid noisy timeouts
      id: reach
      uses: ./.github/actions/common/ssh-probe
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}

    - name: Fail when SSH host is unreachable
      if: ${{ steps.reach.outputs.reachable != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        # When the SSH probe cannot reach the remote host, fail fast with a
        # descriptive error so the overall app summary reports a failure
        # instead of "deployed successfully". Example:
        #   Host 'example.com' unreachable after 3 attempts on port 22.
        #   Last error: ssh: connect to host example.com port 22: Connection timed out
        echo "::error title=SSH host unreachable::SSH host '${{ inputs.ssh_host }}' is unreachable after ${{ steps.reach.outputs.attempts }} attempt(s) on port ${{ inputs.ssh_port }}."
        if [ -n "${{ steps.reach.outputs.last_error }}" ]; then
          echo "Last SSH error message:" >&2
          printf '%s\n' "${{ steps.reach.outputs.last_error }}" >&2
        fi
        echo "" >&2
        echo "Hints:" >&2
        echo "  - Verify the server is online and reachable (ping, DNS, routing)." >&2
        echo "  - Confirm SSH is listening on port ${{ inputs.ssh_port }} and not firewalled." >&2
        echo "  - Check that ssh_user='${{ inputs.ssh_user }}' and the provided ssh_key are valid." >&2
        exit 1

    - name: Ensure server scripts bundle is deployed
      id: scripts
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.ensure_scripts_deployed == 'true' }}
      uses: ./.github/actions/infra/deploy-server-scripts
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}

    - name: Resolve env secret (optional)
      id: envsel
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.auto_fetch_env == 'true' && (inputs.env_b64 == '' && inputs.env_content == '') }}
      uses: ./.github/actions/common/select-env-secret
      with:
        env_name: ${{ steps.dfl.outputs.env_name_default }}
        secrets_json: ${{ inputs.secrets_json }}
        secret_prefix: ${{ inputs.env_secret_prefix }}
        secret_suffix: ${{ inputs.env_secret_suffix }}
        required: false

    - name: Deploy preflight # Validate inputs, optional host prep, write env, registry login
      id: preflight
      if: ${{ steps.reach.outputs.reachable == 'true' }}
      uses: ./.github/actions/app/common/deploy-preflight
      with:
        ssh_host: ${{ inputs.ssh_host }} # Remote host
        ssh_user: ${{ inputs.ssh_user }} # SSH user
        ssh_key: ${{ inputs.ssh_key }} # SSH key for ssh_user
        root_ssh_key: ${{ inputs.root_ssh_key }} # Optional root key
        ssh_port: ${{ inputs.ssh_port }} # SSH port
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }} # Host key pin
        app_slug: ${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }} # Derived slug
        prepare_host: ${{ inputs.prepare_host }} # Run host prep (defaults to true for ssh-container-deploy)
        install_podman: ${{ inputs.install_podman }} # Install podman
        install_traefik: ${{ inputs.install_traefik }} # Install Traefik
        traefik_enable_acme: ${{ inputs.enable_acme }} # Whether to enable ACME in Traefik setup
        traefik_email: ${{ inputs.traefik_email }} # Email for LE certs
        traefik_domain: ${{ inputs.domain != '' && inputs.domain || steps.dfl.outputs.domain_default }} # FQDN for Traefik
        traefik_domain_apex: ${{ steps.dfl.outputs.domain_apex }} # Apex for fallback email
        env_dir_path: ${{ inputs.env_dir_path != '' && inputs.env_dir_path || steps.dfl.outputs.env_dir_path }} # Env dir on host
        additional_packages: ${{ inputs.additional_packages }} # Extra apt packages
        ufw_allow_ports: ${{ inputs.ufw_allow_ports }} # Ports to allow via UFW
        debug: ${{ inputs.debug }}
        write_env_file: ${{ (inputs.write_env_file == 'true') || (inputs.env_b64 != '' || inputs.env_content != '' || steps.envsel.outputs.env_b64 != '') }} # Whether to write the .env
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }} # Env name
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }} # Base env path
        env_b64: ${{ inputs.env_b64 != '' && inputs.env_b64 || steps.envsel.outputs.env_b64 }} # Base64 payload for .env
        env_content: ${{ inputs.env_content }} # Raw payload for .env
        registry: ${{ inputs.registry }} # Registry host
        registry_username: ${{ inputs.registry_username }} # Registry user
        registry_token: ${{ inputs.registry_token }} # Registry token
        registry_login: ${{ inputs.registry_login }} # Login before pull
        perform_pull: 'false'
        image_name: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }} # Image path
        image_tag: ${{ inputs.version != '' && inputs.version || (inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default) }} # Tag


    - name: Deployment Banner
      shell: bash
      run: |
        TAG="${{ inputs.version != '' && inputs.version || (inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default) }}"
        echo "::notice::ðŸš€ Starting Deployment to ${{ inputs.ssh_host }}"
        echo "::notice::ðŸ“¦ Image: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}:$TAG"


    - name: Deploy container # Start/replace container with Traefik or port mapping
      if: ${{ steps.reach.outputs.reachable == 'true' }}
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ inputs.ssh_user }}
        key: ${{ inputs.ssh_key }}
        port: ${{ inputs.ssh_port }}
        fingerprint: ${{ inputs.ssh_fingerprint }}
        script: |
          echo "================================================================"
          echo "Deploying container via SSH..."
          echo "================================================================"
          # ------------------------------------------------------------------
          # Export deployment variables for run-deployment.sh
          # ------------------------------------------------------------------
          # Env payload (optional)
          export ENV_B64='${{ inputs.env_b64 != '' && inputs.env_b64 || steps.envsel.outputs.env_b64 }}'
          export ENV_CONTENT='${{ inputs.env_content }}'

          # Registry & image
          export IMAGE_REGISTRY='${{ inputs.registry }}'
          export IMAGE_NAME='${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}'
          export IMAGE_TAG='${{ inputs.version != '' && inputs.version || (inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default) }}'
          export REGISTRY_LOGIN='${{ inputs.registry_login }}'
          if [ '${{ inputs.registry }}' = 'ghcr.io' ]; then
            export REGISTRY_USERNAME='${{ inputs.registry_username != '' && inputs.registry_username || github.actor }}'
            export REGISTRY_TOKEN='${{ inputs.registry_token != '' && inputs.registry_token || github.token }}'
          else
            export REGISTRY_USERNAME='${{ inputs.registry_username }}'
            export REGISTRY_TOKEN='${{ inputs.registry_token }}'
          fi

          # App identity & environment
          export APP_SLUG='${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}'
          export ENV_NAME='${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}'
          export CONTAINER_NAME_IN="${{ inputs.container_name }}"

          # Paths on host
          if [ -n '${{ inputs.env_file_path }}' ]; then
            export ENV_FILE_PATH_BASE='${{ inputs.env_file_path }}'
          else
            export ENV_FILE_PATH_BASE='${{ inputs.deployment_base_dir }}'
          fi

          DEPLOYMENT_ROOT="$ENV_FILE_PATH_BASE"
          if [ -z "$DEPLOYMENT_ROOT" ]; then
            DEPLOYMENT_ROOT="$HOME/deployments"
          fi
          case "$DEPLOYMENT_ROOT" in
            "~/"*) DEPLOYMENT_ROOT="$HOME/${DEPLOYMENT_ROOT#~/}" ;;
            "/home/runner/"*) DEPLOYMENT_ROOT="$HOME/${DEPLOYMENT_ROOT#/home/runner/}" ;;
          esac
          DEPLOYMENT_ROOT="${DEPLOYMENT_ROOT%/}"
          export REMOTE_DEPLOYMENT_DIR="${DEPLOYMENT_ROOT}/${ENV_NAME}/${APP_SLUG}"

          # Ports & runtime
          export HOST_PORT_IN='${{ inputs.host_port != '' && inputs.host_port || inputs.default_host_port }}'
          export CONTAINER_PORT_IN='${{ inputs.container_port != '' && inputs.container_port || inputs.default_container_port }}'
          export EXTRA_RUN_ARGS='${{ inputs.extra_run_args }}'
          export RESTART_POLICY='${{ inputs.restart_policy }}'
          export MEMORY_LIMIT='${{ inputs.memory_limit }}'
          export CPU_LIMIT='${{ inputs.cpu_limit }}'

          # Traefik & domain routing
          export TRAEFIK_ENABLED='${{ inputs.enable_traefik }}'
          export TRAEFIK_ENABLE_ACME='${{ inputs.enable_acme }}'
          export TRAEFIK_EMAIL='${{ inputs.traefik_email }}'
          export TRAEFIK_RESET_ACME='${{ inputs.traefik_reset_acme }}'
          export TRAEFIK_NETWORK_NAME='${{ inputs.traefik_network_name }}'
          export DOMAIN_INPUT='${{ inputs.domain }}'
          export DOMAIN_DEFAULT='${{ steps.dfl.outputs.domain_default }}'
          export ROUTER_NAME='${{ steps.dfl.outputs.traefik_router }}'
          export DOMAIN_ALIASES='${{ inputs.domain_aliases }}'
          export INCLUDE_WWW_ALIAS='${{ inputs.include_www_alias }}'
          export DOMAIN_HOSTS='${{ inputs.domain_hosts }}'

          # Debug & diagnostics toggles
          export DEBUG='${{ inputs.debug }}'
          export PROBE_HTTP_FALLBACK=true
          export PROBE_TIMEOUT=12
          export PROBE_TRIES=12
          export PROBE_DELAY=5

          # Host hardening & optional services
          export SSH_PORT='${{ inputs.ssh_port }}'
          export UFW_ALLOW_PORTS_INPUT='${{ inputs.ufw_allow_ports }}'
          export INSTALL_WEBMIN='${{ inputs.install_webmin }}'
          export INSTALL_USERMIN='${{ inputs.install_usermin }}'
          export INSTALL_PORTAINER='${{ inputs.install_portainer }}'
          export PORTAINER_HTTPS_PORT='${{ inputs.portainer_https_port }}'
          # When PORTAINER_DOMAIN is set (for example portainer.shakohub.com), the
          # install-portainer.sh script will attach Traefik labels so the UI is
          # reachable via HTTPS on 443 at that host in addition to any direct
          # :9443 binding.
          export PORTAINER_DOMAIN='${{ inputs.portainer_domain }}'

          # Portainer admin auto-init controls. These are passed through to the
          # install-portainer.sh script so it can bootstrap the initial admin
          # user via the HTTPS API on first install. Example overrides:
          #   - portainer_admin_auto_init: 'false' (manual UI/API setup)
          #   - portainer_admin_password: '<admin-password-from-workflow-secret>'
          export PORTAINER_ADMIN_AUTO_INIT='${{ inputs.portainer_admin_auto_init }}'
          export PORTAINER_ADMIN_USERNAME='${{ inputs.portainer_admin_username }}'
          export PORTAINER_ADMIN_PASSWORD='${{ inputs.portainer_admin_password }}'

          # Quadlet/systemd persistence toggle for app containers. When set to
          # 'false', deploy-container.sh will skip generating a Quadlet
          # .container unit so the app is not managed by systemd --user.
          export QUADLET_ENABLED='${{ inputs.quadlet_enabled }}'

          # Propagate Traefik ensure hint to the remote orchestration layer. When
          # ensure_traefik=false, run-deployment.sh will skip ensure-traefik-ready
          # entirely so that Traefik can be managed out-of-band. The TRAEFIK_MODE
          # guard defaults to the container-managed path inside the scripts.
          export ENSURE_TRAEFIK='${{ inputs.ensure_traefik }}'

          # TRAEFIK_MODE controls whether Traefik is managed via Quadlet/socket-
          # activation ('quadlet') or as a standalone Podman container ('container').
          # This variable is computed below based on Podman version and passed to
          # the remote scripts so they don't override it based on stale file presence.
          # Example: Podman 3.4.4 cannot use Quadlet reliably, so TRAEFIK_MODE=container.

          # Podman storage cleanup controls. When enabled (default),
          # run-deployment.sh will invoke prune-podman-storage.sh after a
          # successful deployment to remove old, unused containers/images and
          # keep Podman overlay storage from growing without bound.
          export PODMAN_PRUNE_ENABLED='${{ inputs.enable_podman_cleanup }}'
          export PODMAN_PRUNE_MIN_AGE_DAYS='${{ inputs.podman_cleanup_min_age_days }}'
          export PODMAN_PRUNE_KEEP_RECENT_IMAGES='${{ inputs.podman_cleanup_keep_recent_images }}'
          export PODMAN_PRUNE_AGGRESSIVE='${{ inputs.podman_cleanup_aggressive }}'


          echo "================================================================"
          echo "Installing server-managed scripts bundle on remote host"
          echo "================================================================"
          mkdir -p "$HOME/uactions"
          # Use the exact bundle uploaded for this run when available. The
          # deploy-server-scripts action exposes the staged tarball basename as
          # an output (for example uactions-scripts-<run>-<attempt>.tgz). This
          # prevents concurrent workflows from accidentally consuming each
          # other's bundles. When no bundle name is provided (for example when
          # ensure_scripts_deployed=false or skip_upload=true), fall back to the
          # legacy uactions-scripts.tgz path without touching any other files.
          BUNDLE_PATH=""
          BUNDLE_BASENAME='${{ steps.scripts.outputs.tar_basename }}'
          if [ -n "$BUNDLE_BASENAME" ] && [ -f "$HOME/$BUNDLE_BASENAME" ]; then
            BUNDLE_PATH="$HOME/$BUNDLE_BASENAME"
          elif [ -f "$HOME/uactions-scripts.tgz" ]; then
            BUNDLE_PATH="$HOME/uactions-scripts.tgz"
          fi
          if [ -z "$BUNDLE_PATH" ] || [ ! -f "$BUNDLE_PATH" ]; then
            echo "::error::No uactions scripts bundle found on remote host (expected $HOME/uactions-scripts-<run>-<attempt>.tgz or uactions-scripts.tgz)";
            exit 1
          fi
          ln -sf "$BUNDLE_PATH" "$HOME/uactions-scripts.tgz"
          # Validate tarball integrity to avoid 'tar: empty archive'
          if ! tar -tzf "$BUNDLE_PATH" >/dev/null 2>&1; then
            echo "::error::Invalid or empty tar archive at $BUNDLE_PATH (tar -tzf failed)";
            ls -lh "$BUNDLE_PATH" || true
            exit 1
          fi
          # Replace scripts atomically
          TMPDIR="$(mktemp -d)"
          tar -xzf "$BUNDLE_PATH" -C "$TMPDIR"
          rm -rf "$HOME/uactions/scripts"
          mv "$TMPDIR/scripts" "$HOME/uactions/scripts"
          rm -rf "$TMPDIR"
          # Ensure all scripts are executable
          find "$HOME/uactions/scripts" -type f -name '*.sh' -exec chmod +x {} +
          # Stamp version marker for visibility
          date -u +'%Y-%m-%d %H:%M:%S UTC' > "$HOME/uactions/scripts/.deployed_at"
          echo '${{ github.sha }}' > "$HOME/uactions/scripts/.version"
          echo "================================================================"
          echo "âœ… Scripts installed. Launching container deployment orchestrator ..."
          # Minimal environment for remote entry to handle UFW/Webmin and deploy

          # Default Traefik toggles to true when domain present and caller omitted explicit values
          if [ -z "${TRAEFIK_ENABLED}" ]; then
            if [ -n "${DOMAIN_INPUT}" ] || [ -n "${DOMAIN_DEFAULT}" ]; then
              TRAEFIK_ENABLED='true'
            else
              TRAEFIK_ENABLED='false'
            fi
          fi
          if [ -z "${TRAEFIK_ENABLE_ACME}" ] && [ "${TRAEFIK_ENABLED}" = "true" ]; then
            TRAEFIK_ENABLE_ACME='true'
          fi
          # Derive fallback ACME email when missing so setup-traefik does not fail fast
          if [ -z "${TRAEFIK_EMAIL}" ]; then
            DOMAIN_FOR_EMAIL="${DOMAIN_DEFAULT:-${DOMAIN_INPUT:-}}"
            if [ -n "${DOMAIN_FOR_EMAIL}" ]; then
              lower_domain=$(printf '%s' "${DOMAIN_FOR_EMAIL}" | tr '[:upper:]' '[:lower:]')
              # Use apex part for email when www or subdomain provided
              IFS='.' read -r -a email_parts <<<"${lower_domain#www.}"
              part_count=${#email_parts[@]}
              if [ "$part_count" -ge 2 ]; then
                apex="${email_parts[part_count-2]}.${email_parts[part_count-1]}"
              else
                apex="${lower_domain#www.}"
              fi
              TRAEFIK_EMAIL="traefik@${apex}"
            fi
          fi

          # Prefer Quadlet-managed Traefik when the Quadlet installer is
          # available on the host **and** the host Podman version is new
          # enough to support Quadlet generators reliably (Podman >= 4.4).
          # Older Podman releases (for example 3.x on some distributions) do
          # not ship Quadlet support, which would cause silent failures on
          # ports 80/443 if we forced TRAEFIK_MODE=quadlet.
          #
          # IMPORTANT: We MUST explicitly export TRAEFIK_MODE so that
          # run-deployment.sh does not override it based on stale Quadlet
          # files left from previous failed deployments. Example scenario:
          #   - Server has Podman 3.4.4 (no Quadlet support)
          #   - Previous deployment left ~/.config/systemd/user/http.socket
          #   - Without explicit export, run-deployment.sh would detect files
          #     and set TRAEFIK_MODE=quadlet, causing socket activation failures
          if [ -z "${TRAEFIK_MODE:-}" ]; then
            podman_ver=""
            if command -v podman >/dev/null 2>&1; then
              podman_ver=$(podman --version 2>/dev/null | awk '{print $3}' | cut -d'-' -f1 || echo "")
            fi
            if [ -n "$podman_ver" ]; then
              podman_major="${podman_ver%%.*}"
              podman_minor_patch="${podman_ver#*.}"
              podman_minor="${podman_minor_patch%%.*}"
              if { [ "$podman_major" -gt 4 ] || { [ "$podman_major" -eq 4 ] && [ "$podman_minor" -ge 4 ]; }; }; then
                # Podman >= 4.4 supports Quadlet; check if installer is available
                if [ -x "$HOME/uactions/scripts/traefik/install-quadlet-sockets.sh" ]; then
                  export TRAEFIK_MODE='quadlet'
                  echo "::notice::Podman $podman_ver supports Quadlet; using TRAEFIK_MODE=quadlet." >&2
                else
                  export TRAEFIK_MODE='container'
                  echo "::notice::Podman $podman_ver supports Quadlet but installer not found; using TRAEFIK_MODE=container." >&2
                fi
              else
                # Podman < 4.4 does NOT support Quadlet reliably
                export TRAEFIK_MODE='container'
                echo "::notice::Podman version $podman_ver does not support Quadlet (requires >= 4.4); using TRAEFIK_MODE=container." >&2
              fi
            else
              # Podman not found or version unknown - default to container mode
              export TRAEFIK_MODE='container'
              echo "::notice::Podman not found or version unknown; using TRAEFIK_MODE=container." >&2
            fi
          else
            # TRAEFIK_MODE was already set (e.g., by caller); export it as-is
            export TRAEFIK_MODE
            echo "::notice::Using caller-provided TRAEFIK_MODE=$TRAEFIK_MODE." >&2
          fi

          "$HOME/uactions/scripts/app/start-container-deployment.sh"

          
   
    # # Respect summary_mode: full|light|off
    # # - full: run diagnostics + whoami probe
    # # - light: skip diagnostics (fast), still summarize remote state
    # # - off: skip summary step entirely
    # - name: Deployment status summary
    #   if: ${{ steps.reach.outputs.reachable == 'true' && inputs.summary_mode != 'off' }}
    #   continue-on-error: true
    #   uses: ./.github/actions/app/deployment-status-summary
    #   with:
    #     reachable: ${{ steps.reach.outputs.reachable }}
    #     ssh_host: ${{ inputs.ssh_host }}
    #     ssh_user: ${{ inputs.ssh_user != '' && inputs.ssh_user || inputs.podman_user }}
    #     ssh_key: ${{ inputs.ssh_key }}
    #     ssh_port: ${{ inputs.ssh_port }}
    #     app_slug: ${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}
    #     env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        
    #     #  Status summary requires the app slug, container name and ports to
    #     #  summarize endpoint reachability among other more detailed metrics
    #     container_name: ${{ inputs.container_name }}
    #     enable_traefik: ${{ inputs.enable_traefik }}
    #     domain_effective: ${{ inputs.domain != '' && inputs.domain || steps.dfl.outputs.domain_default }}
    #     host_port: ${{ inputs.host_port != '' && inputs.host_port || inputs.default_host_port }}
    #     container_port: ${{ inputs.container_port != '' && inputs.container_port || inputs.default_container_port }}
    #     router_name: ${{ steps.dfl.outputs.traefik_router }}
    #     whoami_probe: ${{ inputs.ensure_traefik == 'true' && inputs.enable_traefik == 'true' && inputs.summary_mode == 'full' }}
    #     traefik_network_name: ${{ inputs.traefik_network_name }}
    #     run_diagnostics: ${{ inputs.summary_mode == 'full' }}
    #     diagnostics_fail_on_issues: 'false'
