# ============================================================================
# ACTION: SSH Container Deploy
# ============================================================================
# PURPOSE:
# Deploys a generic containerized application to a remote server via SSH using
# Podman. Supports Traefik routing by default when a domain is provided and
# falls back to host port mapping when no domain is available.
#
# WHAT IT DOES:
# 1. Optionally prepares a fresh Ubuntu host (Podman, Traefik, directories)
# 2. Writes environment file to remote server
# 3. Logs in to container registry and pulls image
# 4. Starts container with Traefik labels or host port mapping
#
# WHEN TO USE:
# - Deploy any containerized app (web/API/etc.)
# - Supports production, staging, development
# - First-time host prep (prepare_host: true) or repeat deploys
# ============================================================================

name: 'SSH Container Deploy' # Action name as shown in logs/marketplace
description: 'Deploy a container via Podman over SSH with optional Traefik routing and/or port mapping.' # High-level summary

inputs: # All parameters accepted by this action
  # SSH / Remote
  ssh_host: # SSH host (IP or DNS)
    required: true # Must be provided by caller
  ssh_user: # SSH username; root supported
    required: false
    default: 'root' # Defaults to root unless overridden
  ssh_key: # Private key for ssh_user
    required: true
  root_ssh_key: # Optional private key for root for privilege operations
    required: false
  ssh_port: # SSH port on remote host
    required: false
    default: '22'
  ssh_fingerprint: # Optional host key fingerprint for trust pinning
    required: false
  podman_user: # Remote Linux user that runs podman commands
    required: false
    default: 'deployer'
  connect_mode: # How to connect: auto|root|user
    required: false
    default: 'auto'
  skip_upload:
    description: 'Skip staging/upload of deploy-container.sh (assumes scripts deployed via infra/deploy-server-scripts)'
    required: false
    default: 'true'
  ensure_scripts_deployed:
    description: 'Automatically deploy the server scripts bundle before any remote steps'
    required: false
    default: 'true'

  # Smart defaults
  default_host_port:
    description: 'Default host port when not using Traefik and no host_port provided'
    required: false
    default: '8080'
  default_container_port:
    description: 'Default container port when not provided'
    required: false
    default: '8080'

  # Auto env secret resolution (reads job env like PROD_ENV_B64/STAGING_ENV_B64/DEV_ENV_B64)
  auto_fetch_env:
    description: 'When true and env_b64 not provided, resolve from job env based on env_name'
    required: false
    default: 'true'
  env_secret_prefix:
    description: 'Prefix for env secret env var name'
    required: false
    default: ''
  env_secret_suffix:
    description: 'Suffix for env secret env var name'
    required: false
    default: '_ENV_B64'

  # Host prep
  prepare_host: # If true, prepare a fresh Ubuntu host (podman, users, dirs)
    required: false
    default: 'false'
  install_podman: # Install Podman during host prep
    required: false
    default: 'true'
  create_podman_user: # Create the podman_user if missing
    required: false
    default: 'false'
  install_traefik: # Install Traefik reverse proxy during host prep
    required: false
    default: 'true'
  traefik_email: # Email for Let's Encrypt (used by Traefik)
    required: false
  env_dir_path: # Base dir on host for env files and app data (e.g., /var/deployments)
    required: false
  additional_packages: # Extra apt packages to install on host prep
    required: false
    default: 'jq curl ca-certificates'
  ufw_allow_ports: # Space-separated ports to open in UFW during prep
    required: false
    default: ''

  # Env file
  env_name: # Environment: production|staging|development (auto if omitted)
    required: false
  auto_detect_env: # When true, derive env from branch/tag
    required: false
    default: 'true'
  env_file_path: # Remote base path for env files (default derived)
    required: false
  write_env_file: # Write env to host before deploy (true when env payload present)
    required: false
    default: 'false'
  env_b64: # Base64-encoded .env content to write
    required: false
  env_content: # Raw .env content (use env_b64 when possible)
    required: false

  # Registry & image
  registry: # Registry hostname (e.g., ghcr.io, docker.io)
    required: false
    default: 'ghcr.io'
  image_name: # Image path (org/repo)
    required: false
  image_tag: # Image tag (e.g., v1.2.3 or env-sha)
    required: false
  registry_username: # Registry username (needed for non-GHCR private)
    required: false
  registry_token: # Registry token/password
    required: false
  registry_login: # Perform login before pull
    required: false
    default: 'true'

  # Runtime
  app_slug: # Slug for app; defaults from repo name
    required: false
  container_name: # Override container name (<app>-<env> if omitted)
    required: false
  host_port: # Host port to publish (when not using Traefik)
    required: false
  container_port: # Container port to expose (service port for Traefik or mapping)
    required: false
  restart_policy: # Podman restart policy
    required: false
    default: 'unless-stopped'
  extra_run_args: # Extra args for podman run
    required: false
  memory_limit: # Memory limit (and swap) for the container
    required: false
    default: '512m'

  # Env sourcing for deployment
  source_env: # Source the .env on remote before running deploy script
    required: false
    default: 'true'
  fail_if_env_missing: # Fail if .env missing and source_env=true
    required: false
    default: 'true'

  # Domain / Traefik
  enable_traefik: # When true and domain present, attach Traefik labels
    required: false
    default: 'true'
  domain: # Explicit FQDN to use for routing (optional)
    required: false
  base_domain: # Apex domain; we derive per-env subdomain when set
    required: false
  domain_prefix_prod: # Prefix for prod subdomain ('' for apex)
    required: false
    default: ''
  domain_prefix_staging: # Prefix for staging subdomain
    required: false
  domain_prefix_dev: # Prefix for dev subdomain
    required: false
  require_dns_match: # (Reserved) Gate changes behind DNS match
    required: false
    default: 'true'

runs: # Composite action implementation
  using: 'composite'
  steps:
    - name: Compute derived defaults # Derive slug, env, domain, tags, etc.
      id: dfl
      uses: ./.github/actions/app/common/compute-defaults
      with:
        env_name: ${{ inputs.env_name }} # Optional explicit env
        auto_detect_env: ${{ inputs.auto_detect_env }} # Derive env from branch/tag when true
        domain: ${{ inputs.domain }} # Optional override FQDN
        base_domain: ${{ inputs.base_domain }} # Apex domain to compute FQDN
        domain_prefix_prod: ${{ inputs.domain_prefix_prod }} # Prod prefix
        domain_prefix_staging: ${{ inputs.domain_prefix_staging }} # Staging prefix
        domain_prefix_dev: ${{ inputs.domain_prefix_dev }} # Dev prefix

    - name: Check SSH reachability # Fast pre-probe to avoid noisy timeouts
      id: reach
      shell: bash
      env:
        SSH_HOST: ${{ inputs.ssh_host }}
        SSH_USER: ${{ inputs.ssh_user != '' && inputs.ssh_user || 'root' }}
        SSH_KEY: ${{ inputs.ssh_key }}
        SSH_PORT: ${{ inputs.ssh_port }}
      run: |
        set -euo pipefail
        KEY_FILE="$(mktemp)"
        trap "rm -f '$KEY_FILE'" EXIT
        if printf '%s' "$SSH_KEY" | grep -q '\\n'; then
          printf '%s\n' "$SSH_KEY" | sed 's/\\n/\n/g' > "$KEY_FILE"
        else
          printf '%s\n' "$SSH_KEY" > "$KEY_FILE"
        fi
        chmod 600 "$KEY_FILE"
        ok=false
        for i in 1 2 3; do
          if ssh -i "$KEY_FILE" -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=8 -p "${SSH_PORT:-22}" "$SSH_USER@$SSH_HOST" true 2>/dev/null; then
            ok=true; break
          fi
          sleep 5
        done
        if $ok; then echo "reachable=true" >> "$GITHUB_OUTPUT"; else echo "reachable=false" >> "$GITHUB_OUTPUT"; fi

    - name: Ensure server scripts bundle is deployed
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.ensure_scripts_deployed == 'true' }}
      uses: ./.github/actions/infra/deploy-server-scripts
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user != '' && inputs.ssh_user || 'root' }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}

    - name: Check Traefik presence (optional) # Probe server for Traefik if enabled
      id: check_traefik
      if: ${{ inputs.enable_traefik == 'true' && steps.reach.outputs.reachable == 'true' }}
      uses: appleboy/ssh-action@v1.0.3
      continue-on-error: true
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ inputs.ssh_user != '' && inputs.ssh_user || 'root' }}
        key: ${{ inputs.ssh_key }}
        port: ${{ inputs.ssh_port }}
        fingerprint: ${{ inputs.ssh_fingerprint }}
        script: |
          set -euo pipefail
          # 1) systemd service (if Traefik was started as service)
          if command -v systemctl >/dev/null 2>&1 && systemctl is-active --quiet traefik; then exit 0; fi
          # 2) podman container named "traefik" as podman user
          if command -v runuser >/dev/null 2>&1 && runuser -l ${{ inputs.podman_user }} -c "podman ps -a --format '{{.Names}}' | grep -qx traefik" 2>/dev/null; then exit 0; fi
          # 3) podman container named "traefik" as root (fallback)
          if command -v podman >/dev/null 2>&1 && podman ps -a --format '{{.Names}}' | grep -qx traefik; then exit 0; fi
          # Not found
          exit 1

    - name: Compute effective prepare_host # Auto-enable prep when Traefik missing
      id: eff
      shell: bash
      env:
        PREPARE_IN: ${{ inputs.prepare_host }}
        ENABLE_TRAEFIK: ${{ inputs.enable_traefik }}
        CHECK_OUTCOME: ${{ steps.check_traefik.outcome }}
      run: |
        set -euo pipefail
        EFFECTIVE="false"
        if [ "${PREPARE_IN}" = "true" ]; then
          EFFECTIVE="true"
        elif [ "${ENABLE_TRAEFIK}" = "true" ] && [ "${CHECK_OUTCOME:-skipped}" = "failure" ]; then
          EFFECTIVE="true"
        fi
        printf 'prepare_host=%s\n' "$EFFECTIVE" >> "$GITHUB_OUTPUT"

    - name: Resolve env secret (optional)
      id: envsel
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.auto_fetch_env == 'true' && (inputs.env_b64 == '' && inputs.env_content == '') }}
      shell: bash
      env:
        ENV_NAME_DEFAULT: ${{ steps.dfl.outputs.env_name_default }}
        PREFIX: ${{ inputs.env_secret_prefix }}
        SUFFIX: ${{ inputs.env_secret_suffix }}
      run: |
        set -euo pipefail
        key=""
        case "${ENV_NAME_DEFAULT:-development}" in
          production) key="PROD" ;;
          staging) key="STAGING" ;;
          *) key="DEV" ;;
        esac
        varname="${PREFIX}${key}${SUFFIX}"
        echo "Looking for env var: $varname"
        val=${!varname:-}
        if [ -n "$val" ]; then
          echo "env_b64 resolved from $varname"
          printf 'env_b64=%s\n' "$val" >> "$GITHUB_OUTPUT"
        else
          echo "env_b64 not found in job env for $varname (will proceed without writing .env)"
        fi

    - name: Deploy preflight # Validate inputs, optional host prep, write env, registry login
      if: ${{ steps.reach.outputs.reachable == 'true' }}
      uses: ./.github/actions/app/common/deploy-preflight
      with:
        ssh_host: ${{ inputs.ssh_host }} # Remote host
        ssh_user: ${{ inputs.ssh_user != '' && inputs.ssh_user || 'root' }} # SSH user
        ssh_key: ${{ inputs.ssh_key }} # SSH key for ssh_user
        root_ssh_key: ${{ inputs.root_ssh_key }} # Optional root key
        ssh_port: ${{ inputs.ssh_port }} # SSH port
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }} # Host key pin
        podman_user: ${{ inputs.podman_user != '' && inputs.podman_user || 'deployer' }} # Podman user on host
        connect_mode: ${{ inputs.connect_mode }} # auto|root|user
        app_slug: ${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }} # Derived slug
        prepare_host: ${{ steps.eff.outputs.prepare_host }} # Run host prep?
        install_podman: ${{ inputs.install_podman }} # Install podman
        create_podman_user: ${{ inputs.create_podman_user }} # Create podman user
        install_traefik: ${{ inputs.install_traefik }} # Install Traefik
        traefik_email: ${{ inputs.traefik_email }} # Email for LE certs
        traefik_domain: ${{ inputs.domain != '' && inputs.domain || steps.dfl.outputs.domain_default }} # FQDN for Traefik
        traefik_domain_apex: ${{ steps.dfl.outputs.domain_apex }} # Apex for fallback email
        env_dir_path: ${{ inputs.env_dir_path != '' && inputs.env_dir_path || steps.dfl.outputs.env_dir_path }} # Env dir on host
        additional_packages: ${{ inputs.additional_packages }} # Extra apt packages
        ufw_allow_ports: ${{ inputs.ufw_allow_ports }} # Ports to allow via UFW
        write_env_file: ${{ (inputs.write_env_file == 'true') || (inputs.env_b64 != '' || inputs.env_content != '' || steps.envsel.outputs.env_b64 != '') }} # Whether to write the .env
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }} # Env name
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }} # Base env path
        env_b64: ${{ inputs.env_b64 != '' && inputs.env_b64 || steps.envsel.outputs.env_b64 }} # Base64 payload for .env
        env_content: ${{ inputs.env_content }} # Raw payload for .env
        registry: ${{ inputs.registry }} # Registry host
        registry_username: ${{ inputs.registry_username }} # Registry user
        registry_token: ${{ inputs.registry_token }} # Registry token
        registry_login: ${{ inputs.registry_login }} # Login before pull
        perform_pull: 'false'
        image_name: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }} # Image path
        image_tag: ${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }} # Tag

    - name: Stage run-deployment script for upload
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.skip_upload != 'true' }}
      shell: bash
      env:
        ACTION_PATH: ${{ github.action_path }}
        WORKSPACE: ${{ github.workspace }}
      run: |
        set -euo pipefail
        mkdir -p "$WORKSPACE/.uactions_cache"
        SRC_REL="../../scripts/app/run-deployment.sh"
        cp "$ACTION_PATH/$SRC_REL" "$WORKSPACE/.uactions_cache/run-deployment.sh"

    - name: Upload deployment scripts
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.skip_upload != 'true' }}
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ inputs.ssh_user != '' && inputs.ssh_user || 'root' }}
        key: ${{ inputs.ssh_key }}
        port: ${{ inputs.ssh_port }}
        source: ".uactions_cache/deploy-container.sh,.uactions_cache/run-deployment.sh"
        target: "/tmp"
        overwrite: true
        strip_components: 1
        timeout: 15s
        command_timeout: 30s

    - name: Deploy container # Start/replace container with Traefik or port mapping
      if: ${{ steps.reach.outputs.reachable == 'true' }}
      uses: ./.github/actions/podman/remote-podman-exec
      with:
        ssh_host: ${{ inputs.ssh_host }} # Remote host
        ssh_user: ${{ inputs.ssh_user != '' && inputs.ssh_user || 'root' }} # SSH user
        ssh_key: ${{ inputs.ssh_key }} # SSH key
        root_ssh_key: ${{ inputs.root_ssh_key }} # Optional root key
        ssh_port: ${{ inputs.ssh_port }} # SSH port
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }} # Host key pin
        podman_user: ${{ inputs.podman_user }} # Podman user
        connect_mode: ${{ inputs.connect_mode }} # Connection mode
        app_slug: ${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }} # Slug
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }} # Env
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }} # Base env path
        source_env: ${{ inputs.source_env }} # Source env before script
        fail_if_env_missing: ${{ inputs.fail_if_env_missing }} # Fail on missing env
        inline_script: |
          set -euo pipefail
          # Ensure scripts directory and move uploaded scripts
          sudo mkdir -p /opt/uactions/scripts/app
          if [ -f /tmp/run-deployment.sh ]; then
            sudo mv -f /tmp/run-deployment.sh /opt/uactions/scripts/app/run-deployment.sh
            sudo chmod +x /opt/uactions/scripts/app/run-deployment.sh
          fi

          # Export deployment variables for run-deployment.sh
          export PODMAN_USER='${{ inputs.podman_user }}'
          export IMAGE_REGISTRY='${{ inputs.registry }}'
          export IMAGE_NAME='${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}'
          export IMAGE_TAG='${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }}'
          export REGISTRY_LOGIN='${{ inputs.registry_login }}'
          if [ '${{ inputs.registry }}' = 'ghcr.io' ]; then
            export REGISTRY_USERNAME='${{ inputs.registry_username != '' && inputs.registry_username || github.actor }}'
            export REGISTRY_TOKEN='${{ inputs.registry_token != '' && inputs.registry_token || github.token }}'
          else
            export REGISTRY_USERNAME='${{ inputs.registry_username }}'
            export REGISTRY_TOKEN='${{ inputs.registry_token }}'
          fi
          export APP_SLUG='${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}'
          export ENV_NAME='${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}'
          export CONTAINER_NAME_IN='${{ inputs.container_name }}'
          export ENV_FILE_PATH_BASE='${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}'
          export HOST_PORT_IN='${{ inputs.host_port != '' && inputs.host_port || inputs.default_host_port }}'
          export CONTAINER_PORT_IN='${{ inputs.container_port != '' && inputs.container_port || inputs.default_container_port }}'
          export EXTRA_RUN_ARGS='${{ inputs.extra_run_args }}'
          export RESTART_POLICY='${{ inputs.restart_policy }}'
          export MEMORY_LIMIT='${{ inputs.memory_limit }}'
          export TRAEFIK_ENABLED='${{ inputs.enable_traefik }}'
          export DOMAIN_INPUT='${{ inputs.domain }}'
          export DOMAIN_DEFAULT='${{ steps.dfl.outputs.domain_default }}'
          export ROUTER_NAME='${{ steps.dfl.outputs.traefik_router }}'

          # Execute deployment runner script
          /opt/uactions/scripts/app/run-deployment.sh

    - name: Deployment status summary
      uses: ./.github/actions/app/deployment-status-summary
      with:
        reachable: ${{ steps.reach.outputs.reachable }}
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user != '' && inputs.ssh_user || 'root' }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        app_slug: ${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        container_name: ${{ inputs.container_name }}
        enable_traefik: ${{ inputs.enable_traefik }}
        domain_effective: ${{ inputs.domain != '' && inputs.domain || steps.dfl.outputs.domain_default }}
        host_port: ${{ inputs.host_port != '' && inputs.host_port || inputs.default_host_port }}
        container_port: ${{ inputs.container_port != '' && inputs.container_port || inputs.default_container_port }}
