# ============================================================================
# ACTION: SSH Container Deploy
# ============================================================================
# PURPOSE:
# Deploys a generic containerized application to a remote server via SSH using
# Podman. Supports Traefik routing by default when a domain is provided and
# falls back to host port mapping when no domain is available.
#
# WHAT IT DOES:
# 1. Optionally prepares a fresh Ubuntu host (Podman, Traefik, directories)
# 2. Writes environment file to remote server
# 3. Logs in to container registry and pulls image
# 4. Starts container with Traefik labels or host port mapping
#
# WHEN TO USE:
# - Deploy any containerized app (web/API/etc.)
# - Supports production, staging, development
# - First-time host prep (prepare_host: true) or repeat deploys
# ============================================================================

name: 'SSH Container Deploy' # Action name as shown in logs/marketplace
description: 'Deploy a container via Podman over SSH with optional Traefik routing and/or port mapping.' # High-level summary

inputs: # All parameters accepted by this action
  # SSH / Remote
  ssh_host:
    description: 'SSH host (IP or DNS) of the remote server (example: deploy.example.com)'
    required: true
  ssh_user:
    description: 'SSH username used for remote execution (example: deploy)'
    required: true
  ssh_key:
    description: 'Private key for ssh_user (PEM). Provide via repository/organization secret.'
    required: true
  root_ssh_key:
    description: 'Optional private key for root for privileged operations (provide via secret)'
    required: false
  ssh_port:
    description: 'SSH port on remote host (default 22)'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Optional host key fingerprint for trust pinning (example: ssh-ed25519 AAAAC3Nza...)'
    required: false
  skip_upload:
    description: 'Skip staging/upload of deploy-container.sh (assumes scripts deployed via infra/deploy-server-scripts)'
    required: false
    default: 'true'
  ensure_scripts_deployed:
    description: 'Automatically deploy the server scripts bundle before any remote steps'
    required: false
    default: 'true'

  # Smart defaults
  default_host_port:
    description: 'Default host port when not using Traefik and no host_port provided'
    required: false
    default: '8080'
  default_container_port:
    description: 'Default container port when not provided'
    required: false
    # NOTE: Project standard default is 8080 (consistent across actions and scripts).
    # Example: if your app listens on 4000, set `container_port: '4000'` (or define
    # WEB_CONTAINER_PORT/TARGET_PORT/PORT in the remote .env) so labels map correctly.
    default: '8080'

  # Deployment directories
  deployment_base_dir:
    description: 'Base directory for deployments on remote server. Default: ~/deployments (user-writable, no sudo required)'
    required: false
    default: '~/deployments'

  # Auto env secret resolution (reads job env like PROD_ENV_B64/STAGING_ENV_B64/DEV_ENV_B64)
  auto_fetch_env:
    description: 'When true and env_b64 not provided, resolve from job env based on env_name'
    required: false
    default: 'true'
  enable_acme:
    description: 'When true (default), attach certresolver label for ACME; set false to skip Let''s Encrypt while debugging.'
    required: false
    default: 'true'
  traefik_network_name:
    description: 'Podman network to connect service containers to when Traefik is enabled (default: traefik-network).'
    required: false
    default: 'traefik-network'
  traefik_use_host_network:
    description: 'Run Traefik on host network to avoid CNI DNS issues (true recommended).'
    required: false
    default: 'false'
  traefik_skip_upload:
    description: 'Skip uploading Traefik scripts (assumes scripts already installed on server).'
    required: false
    default: 'true'
  enable_dashboard:
    description: 'Enable Traefik dashboard exposure (paired with dashboard_publish_modes)'
    required: false
    default: 'true'
  dashboard_publish_modes:
    description: 'CSV of dashboard modes: http8080, https8080, subdomain, or both'
    required: false
    default: ''
  dashboard_host:
    description: 'FQDN for dashboard when using subdomain mode'
    required: false
    default: ''
  dashboard_password:
    description: 'Plain password for admin user (hashed on host). Use dashboard_users_b64 for pre-hashed.'
    required: false
    default: ''
  dashboard_users_b64:
    description: 'Base64-encoded htpasswd-style users file for dashboard auth. Overrides dashboard_password when set.'
    required: false
    default: ''
  dns_servers:
    description: 'Optional comma or space-separated DNS servers for Traefik container (passed as --dns).'
    required: false
    default: ''
  env_secret_prefix:
    description: 'Prefix for env secret env var name'
    required: false
    default: ''
  env_secret_suffix:
    description: 'Suffix for env secret env var name'
    required: false
    default: '_ENV_B64'

  # Host prep
  prepare_host:
    description: "When true, prepare a fresh Ubuntu host (install Podman, create directories, manage users)."
    required: false
    default: 'true'
  install_podman:
    description: "Install Podman during host preparation when not already available (example: true)."
    required: false
    default: 'true'
  create_podman_user:
    description: "Create the podman_user account during host prep when it does not exist (example: false)."
    required: false
    default: 'false'
  install_traefik:
    description: "Install or reconcile the Traefik reverse proxy during host preparation (example: true)."
    required: false
    default: 'true'
  traefik_email:
    description: "Email passed to Traefik's ACME integration for certificate registration (example: ops@example.com)."
    required: false
  env_dir_path:
    description: "Base directory on the host where environment files and app metadata are stored (example: /opt/uactions/envs)."
    required: false
  additional_packages:
    description: "Extra apt packages installed during host preparation (space separated, example: 'jq curl ca-certificates')."
    required: false
    default: 'jq curl ca-certificates'
  ufw_allow_ports:
    description: "Space-separated list of ports opened in UFW during host prep (example: '80 443')."
    required: false
    default: ''
  install_webmin:
    description: 'Install Webmin during host prep/first-run (requires sudo).'
    required: false
    default: 'true'
  install_usermin:
    description: 'Install Usermin alongside Webmin when enabled (requires sudo).'
    required: false
    default: 'false'
  show_root_install_hints:
    description: 'Show explicit manual install instructions when root privileges are required (fail-fast messaging)'
    required: false
    default: 'true'

  # Env file
  env_name:
    description: "Logical environment name (production, staging, development). Auto-derived when omitted."
    required: false
  auto_detect_env:
    description: "When true, derive env_name from branch or tag using compute-defaults (example: true)."
    required: false
    default: 'true'
  env_file_path:
    description: "Remote base path where the .env file should be written (example: /opt/uactions/envs/app.env)."
    required: false
  write_env_file:
    description: "When true, write env_b64 or env_content to the remote server before deployment (example: true)."
    required: false
    default: 'false'
  env_b64:
    description: "Base64-encoded .env payload to materialize on the host (example: a repository/organization secret)."
    required: false
  env_content:
    description: "Raw .env content for the host. Prefer env_b64 for secrets (example: 'KEY=value')."
    required: false

  # Registry & image
  registry:
    description: "Container registry hostname used for image pulls (example: ghcr.io)."
    required: false
    default: 'ghcr.io'
  image_name:
    description: "Repository and image path without tag (example: org/app)."
    required: false
  image_tag:
    description: "Image tag to deploy (example: v1.2.3 or production-abcdef)."
    required: false
  registry_username:
    description: "Registry username for authenticated pulls (example: CI user or bot account)."
    required: false
  registry_token:
    description: "Registry password or token with pull permissions (example: secret token stored in the repository/organization)."
    required: false
  registry_login:
    description: "Attempt Podman login before pulling when credentials exist (example: true)."
    required: false
    default: 'true'

  # Runtime
  app_slug:
    description: "Human-readable slug for the application; defaults from the repo name (example: checkout)."
    required: false
  container_name:
    description: "Container name override; defaults to <app_slug>-<env> (example: checkout-prod)."
    required: false
  host_port:
    description: "Host port to publish when Traefik is disabled (example: 8080)."
    required: false
  container_port:
    description: "Container service port used by Traefik labels or host port mapping (example: 3000)."
    required: false
  restart_policy:
    description: "Podman restart policy applied to the container (example: unless-stopped)."
    required: false
    default: 'unless-stopped'
  extra_run_args:
    description: "Additional flags appended to podman run, provided as a quoted string (example: '--cap-add NET_ADMIN')."
    required: false
  memory_limit:
    description: "Memory limit (and swap) applied to the container (example: 512m)."
    required: false
    default: '512m'

  # Logging / Debugging
  debug:
    description: 'Enable verbose logging, including env paths and user info (default: false)'
    required: false
    default: 'false'

  # Summary & diagnostics verbosity
  summary_mode:
    description: 'Controls deployment summary: full|light|off. full runs diagnostics + whoami probe; light skips diagnostics; off skips summary.'
    required: false
    default: 'full'

  # Env sourcing for deployment
  source_env:
    description: "When true, source the remote .env before executing deployment scripts so exports are available (example: true)."
    required: false
    default: 'true'
  fail_if_env_missing:
    description: "If source_env=true, halt the deployment when the .env file cannot be sourced; set false to proceed without env exports (example: true)."
    required: false
    default: 'true'

  # Domain / Traefik
  enable_traefik:
    description: "When true, attach Traefik labels and network when a domain is provided (example: true)."
    required: false
    default: 'true'
  ensure_traefik:
    description: 'Run infra/setup-traefik to reconcile Traefik (probe-first fast-path). Set false to skip entirely.'
    required: false
    default: 'true'
  domain:
    description: "Explicit domain to route the deployment (example: api.example.com)."
    required: false
  base_domain:
    description: "Base apex domain used to compute per-environment hostnames (example: example.com)."
    required: false
  domain_prefix_prod:
    description: "Prefix to prepend for production environments when base_domain is used (example: '')."
    required: false
    default: ''
  domain_prefix_staging:
    description: "Prefix applied to the staging environment when base_domain is set (example: staging)."
    required: false
  domain_prefix_dev:
    description: "Prefix applied to the development environment when base_domain is set (example: dev)."
    required: false
  require_dns_match:
    description: "Reserved flag to gate changes behind DNS validation (example: true)."
    required: false
    default: 'true'
  domain_aliases:
    description: "Optional comma or space-separated aliases routed to the service (example: 'www.example.com api.example.com')."
    required: false
    default: ''
  include_www_alias:
    description: "When true and domain is set, also include www.<domain> as an alias (example: false)."
    required: false
    default: 'false'
  domain_hosts:
    description: 'CSV of hostnames to route (preferred). Overrides aliases when provided.'
    required: false
    default: ''
  probe_path:
    description: "Path used by Traefik probe to validate deployment readiness (example: /health)."
    required: false
    default: '/'

runs: # Composite action implementation
  using: 'composite'
  steps:
    - name: Compute derived defaults # Derive slug, env, domain, tags, etc.
      id: dfl
      uses: ./.github/actions/app/common/compute-defaults
      with:
        env_name: ${{ inputs.env_name }} # Optional explicit env
        auto_detect_env: ${{ inputs.auto_detect_env }} # Derive env from branch/tag when true
        domain: ${{ inputs.domain }} # Optional override FQDN
        base_domain: ${{ inputs.base_domain }} # Apex domain to compute FQDN
        domain_prefix_prod: ${{ inputs.domain_prefix_prod }} # Prod prefix
        domain_prefix_staging: ${{ inputs.domain_prefix_staging }} # Staging prefix
        domain_prefix_dev: ${{ inputs.domain_prefix_dev }} # Dev prefix

    - name: Probe SSH reachability # Fast pre-probe to avoid noisy timeouts
      id: reach
      uses: ./.github/actions/common/ssh-probe
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}

    - name: Fail when SSH host is unreachable
      if: ${{ steps.reach.outputs.reachable != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        # When the SSH probe cannot reach the remote host, fail fast with a
        # descriptive error so the overall app summary reports a failure
        # instead of "deployed successfully". Example:
        #   Host 'example.com' unreachable after 3 attempts on port 22.
        #   Last error: ssh: connect to host example.com port 22: Connection timed out
        echo "::error title=SSH host unreachable::SSH host '${{ inputs.ssh_host }}' is unreachable after ${{ steps.reach.outputs.attempts }} attempt(s) on port ${{ inputs.ssh_port }}."
        if [ -n "${{ steps.reach.outputs.last_error }}" ]; then
          echo "Last SSH error message:" >&2
          printf '%s\n' "${{ steps.reach.outputs.last_error }}" >&2
        fi
        echo "" >&2
        echo "Hints:" >&2
        echo "  - Verify the server is online and reachable (ping, DNS, routing)." >&2
        echo "  - Confirm SSH is listening on port ${{ inputs.ssh_port }} and not firewalled." >&2
        echo "  - Check that ssh_user='${{ inputs.ssh_user }}' and the provided ssh_key are valid." >&2
        exit 1

    - name: Ensure server scripts bundle is deployed
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.ensure_scripts_deployed == 'true' }}
      uses: ./.github/actions/infra/deploy-server-scripts
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}

    - name: Resolve env secret (optional)
      id: envsel
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.auto_fetch_env == 'true' && (inputs.env_b64 == '' && inputs.env_content == '') }}
      shell: bash
      env:
        ENV_NAME_DEFAULT: ${{ steps.dfl.outputs.env_name_default }}
        PREFIX: ${{ inputs.env_secret_prefix }}
        SUFFIX: ${{ inputs.env_secret_suffix }}
      run: |
        set -euo pipefail
        key=""
        case "${ENV_NAME_DEFAULT:-development}" in
          production) key="PROD" ;;
          staging) key="STAGING" ;;
          *) key="DEV" ;;
        esac
        varname="${PREFIX}${key}${SUFFIX}"
        echo "Looking for env var: $varname"
        val=${!varname:-}
        if [ -n "$val" ]; then
          echo "env_b64 resolved from $varname"
          printf 'env_b64=%s\n' "$val" >> "$GITHUB_OUTPUT"
        else
          echo "env_b64 not found in job env for $varname (will proceed without writing .env)"
        fi

    - name: Deploy preflight # Validate inputs, optional host prep, write env, registry login
      id: preflight
      if: ${{ steps.reach.outputs.reachable == 'true' }}
      uses: ./.github/actions/app/common/deploy-preflight
      with:
        ssh_host: ${{ inputs.ssh_host }} # Remote host
        ssh_user: ${{ inputs.ssh_user }} # SSH user
        ssh_key: ${{ inputs.ssh_key }} # SSH key for ssh_user
        root_ssh_key: ${{ inputs.root_ssh_key }} # Optional root key
        ssh_port: ${{ inputs.ssh_port }} # SSH port
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }} # Host key pin
        app_slug: ${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }} # Derived slug
        prepare_host: ${{ steps.eff.outputs.prepare_host }} # Run host prep?
        install_podman: ${{ inputs.install_podman }} # Install podman
        install_traefik: ${{ inputs.install_traefik }} # Install Traefik
        traefik_enable_acme: ${{ inputs.enable_acme }} # Whether to enable ACME in Traefik setup
        traefik_email: ${{ inputs.traefik_email }} # Email for LE certs
        traefik_domain: ${{ inputs.domain != '' && inputs.domain || steps.dfl.outputs.domain_default }} # FQDN for Traefik
        traefik_domain_apex: ${{ steps.dfl.outputs.domain_apex }} # Apex for fallback email
        env_dir_path: ${{ inputs.env_dir_path != '' && inputs.env_dir_path || steps.dfl.outputs.env_dir_path }} # Env dir on host
        additional_packages: ${{ inputs.additional_packages }} # Extra apt packages
        ufw_allow_ports: ${{ inputs.ufw_allow_ports }} # Ports to allow via UFW
        debug: ${{ inputs.debug }}
        write_env_file: ${{ (inputs.write_env_file == 'true') || (inputs.env_b64 != '' || inputs.env_content != '' || steps.envsel.outputs.env_b64 != '') }} # Whether to write the .env
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }} # Env name
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }} # Base env path
        env_b64: ${{ inputs.env_b64 != '' && inputs.env_b64 || steps.envsel.outputs.env_b64 }} # Base64 payload for .env
        env_content: ${{ inputs.env_content }} # Raw payload for .env
        registry: ${{ inputs.registry }} # Registry host
        registry_username: ${{ inputs.registry_username }} # Registry user
        registry_token: ${{ inputs.registry_token }} # Registry token
        registry_login: ${{ inputs.registry_login }} # Login before pull
        perform_pull: 'false'
        image_name: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }} # Image path
        image_tag: ${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }} # Tag


    - name: Deploy container # Start/replace container with Traefik or port mapping
      if: ${{ steps.reach.outputs.reachable == 'true' }}
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ inputs.ssh_user }}
        key: ${{ inputs.ssh_key }}
        port: ${{ inputs.ssh_port }}
        fingerprint: ${{ inputs.ssh_fingerprint }}
        script: |
          echo "================================================================"
          echo "Deploying container via SSH..."
          echo "================================================================"
          # ------------------------------------------------------------------
          # Export deployment variables for run-deployment.sh
          # ------------------------------------------------------------------
          # Env payload (optional)
          export ENV_B64='${{ inputs.env_b64 != '' && inputs.env_b64 || steps.envsel.outputs.env_b64 }}'
          export ENV_CONTENT='${{ inputs.env_content }}'

          # Registry & image
          export IMAGE_REGISTRY='${{ inputs.registry }}'
          export IMAGE_NAME='${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}'
          export IMAGE_TAG='${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }}'
          export REGISTRY_LOGIN='${{ inputs.registry_login }}'
          if [ '${{ inputs.registry }}' = 'ghcr.io' ]; then
            export REGISTRY_USERNAME='${{ inputs.registry_username != '' && inputs.registry_username || github.actor }}'
            export REGISTRY_TOKEN='${{ inputs.registry_token != '' && inputs.registry_token || github.token }}'
          else
            export REGISTRY_USERNAME='${{ inputs.registry_username }}'
            export REGISTRY_TOKEN='${{ inputs.registry_token }}'
          fi

          # App identity & environment
          export APP_SLUG='${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}'
          export ENV_NAME='${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}'
          export CONTAINER_NAME_IN="${{ inputs.container_name }}"

          # Paths on host
          if [ -n '${{ inputs.env_file_path }}' ]; then
            export ENV_FILE_PATH_BASE='${{ inputs.env_file_path }}'
          else
            export ENV_FILE_PATH_BASE='${{ inputs.deployment_base_dir }}'
          fi

          DEPLOYMENT_ROOT="$ENV_FILE_PATH_BASE"
          if [ -z "$DEPLOYMENT_ROOT" ]; then
            DEPLOYMENT_ROOT="$HOME/deployments"
          fi
          case "$DEPLOYMENT_ROOT" in
            "~/"*) DEPLOYMENT_ROOT="$HOME/${DEPLOYMENT_ROOT#~/}" ;;
            "/home/runner/"*) DEPLOYMENT_ROOT="$HOME/${DEPLOYMENT_ROOT#/home/runner/}" ;;
          esac
          DEPLOYMENT_ROOT="${DEPLOYMENT_ROOT%/}"
          export REMOTE_DEPLOYMENT_DIR="${DEPLOYMENT_ROOT}/${ENV_NAME}/${APP_SLUG}"

          # Ports & runtime
          export HOST_PORT_IN='${{ inputs.host_port != '' && inputs.host_port || inputs.default_host_port }}'
          export CONTAINER_PORT_IN='${{ inputs.container_port != '' && inputs.container_port || inputs.default_container_port }}'
          export EXTRA_RUN_ARGS='${{ inputs.extra_run_args }}'
          export RESTART_POLICY='${{ inputs.restart_policy }}'
          export MEMORY_LIMIT='${{ inputs.memory_limit }}'

          # Traefik & domain routing
          export TRAEFIK_ENABLED='${{ inputs.enable_traefik }}'
          export TRAEFIK_ENABLE_ACME='${{ inputs.enable_acme }}'
          export TRAEFIK_EMAIL='${{ inputs.traefik_email }}'
          export TRAEFIK_NETWORK_NAME='${{ inputs.traefik_network_name }}'
          export DOMAIN_INPUT='${{ inputs.domain }}'
          export DOMAIN_DEFAULT='${{ steps.dfl.outputs.domain_default }}'
          export ROUTER_NAME='${{ steps.dfl.outputs.traefik_router }}'
          export DOMAIN_ALIASES='${{ inputs.domain_aliases }}'
          export INCLUDE_WWW_ALIAS='${{ inputs.include_www_alias }}'
          export DOMAIN_HOSTS='${{ inputs.domain_hosts }}'

          # Debug & diagnostics toggles
          export DEBUG='${{ inputs.debug }}'
          export PROBE_HTTP_FALLBACK=true
          export PROBE_TIMEOUT=12
          export PROBE_TRIES=12
          export PROBE_DELAY=5

          # Host hardening & optional services
          export SSH_PORT='${{ inputs.ssh_port }}'
          export UFW_ALLOW_PORTS_INPUT='${{ inputs.ufw_allow_ports }}'
          export INSTALL_WEBMIN='${{ inputs.install_webmin }}'
          export INSTALL_USERMIN='${{ inputs.install_usermin }}'


          echo "================================================================"
          echo "Installing server-managed scripts bundle on remote host"
          echo "================================================================"
          mkdir -p "$HOME/uactions"
          if [ ! -f "$HOME/uactions-scripts.tgz" ]; then
            echo '::error::Missing $HOME/uactions-scripts.tgz on remote host (upload failed or was skipped)';
            exit 1
          fi
          # Validate tarball integrity to avoid 'tar: empty archive'
          if ! tar -tzf "$HOME/uactions-scripts.tgz" >/dev/null 2>&1; then
            echo '::error::Invalid or empty tar archive at $HOME/uactions-scripts.tgz (tar -tzf failed)';
            ls -lh "$HOME/uactions-scripts.tgz" || true
            exit 1
          fi
          # Replace scripts atomically
          TMPDIR="$(mktemp -d)"
          tar -xzf "$HOME/uactions-scripts.tgz" -C "$TMPDIR"
          rm -rf "$HOME/uactions/scripts"
          mv "$TMPDIR/scripts" "$HOME/uactions/scripts"
          rm -rf "$TMPDIR"
          # Ensure all scripts are executable
          find "$HOME/uactions/scripts" -type f -name '*.sh' -exec chmod +x {} +
          # Stamp version marker for visibility
          date -u +'%Y-%m-%d %H:%M:%S UTC' > "$HOME/uactions/scripts/.deployed_at"
          echo '${{ github.sha }}' > "$HOME/uactions/scripts/.version"
          echo "================================================================"
          echo "âœ… Scripts installed. Launching container deployment orchestrator ..."
          # Minimal environment for remote entry to handle UFW/Webmin and deploy

          # Default Traefik toggles to true when domain present and caller omitted explicit values
          if [ -z "${TRAEFIK_ENABLED}" ]; then
            if [ -n "${DOMAIN_INPUT}" ] || [ -n "${DOMAIN_DEFAULT}" ]; then
              TRAEFIK_ENABLED='true'
            else
              TRAEFIK_ENABLED='false'
            fi
          fi
          if [ -z "${TRAEFIK_ENABLE_ACME}" ] && [ "${TRAEFIK_ENABLED}" = "true" ]; then
            TRAEFIK_ENABLE_ACME='true'
          fi
          # Derive fallback ACME email when missing so setup-traefik does not fail fast
          if [ -z "${TRAEFIK_EMAIL}" ]; then
            DOMAIN_FOR_EMAIL="${DOMAIN_DEFAULT:-${DOMAIN_INPUT:-}}"
            if [ -n "${DOMAIN_FOR_EMAIL}" ]; then
              lower_domain=$(printf '%s' "${DOMAIN_FOR_EMAIL}" | tr '[:upper:]' '[:lower:]')
              # Use apex part for email when www or subdomain provided
              IFS='.' read -r -a email_parts <<<"${lower_domain#www.}"
              part_count=${#email_parts[@]}
              if [ "$part_count" -ge 2 ]; then
                apex="${email_parts[part_count-2]}.${email_parts[part_count-1]}"
              else
                apex="${lower_domain#www.}"
              fi
              TRAEFIK_EMAIL="traefik@${apex}"
            fi
          fi

          "$HOME/uactions/scripts/app/start-container-deployment.sh"

          
   
    # # Respect summary_mode: full|light|off
    # # - full: run diagnostics + whoami probe
    # # - light: skip diagnostics (fast), still summarize remote state
    # # - off: skip summary step entirely
    # - name: Deployment status summary
    #   if: ${{ steps.reach.outputs.reachable == 'true' && inputs.summary_mode != 'off' }}
    #   continue-on-error: true
    #   uses: ./.github/actions/app/deployment-status-summary
    #   with:
    #     reachable: ${{ steps.reach.outputs.reachable }}
    #     ssh_host: ${{ inputs.ssh_host }}
    #     ssh_user: ${{ inputs.ssh_user != '' && inputs.ssh_user || inputs.podman_user }}
    #     ssh_key: ${{ inputs.ssh_key }}
    #     ssh_port: ${{ inputs.ssh_port }}
    #     app_slug: ${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}
    #     env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        
    #     #  Status summary requires the app slug, container name and ports to
    #     #  summarize endpoint reachability among other more detailed metrics
    #     container_name: ${{ inputs.container_name }}
    #     enable_traefik: ${{ inputs.enable_traefik }}
    #     domain_effective: ${{ inputs.domain != '' && inputs.domain || steps.dfl.outputs.domain_default }}
    #     host_port: ${{ inputs.host_port != '' && inputs.host_port || inputs.default_host_port }}
    #     container_port: ${{ inputs.container_port != '' && inputs.container_port || inputs.default_container_port }}
    #     router_name: ${{ steps.dfl.outputs.traefik_router }}
    #     whoami_probe: ${{ inputs.ensure_traefik == 'true' && inputs.enable_traefik == 'true' && inputs.summary_mode == 'full' }}
    #     traefik_network_name: ${{ inputs.traefik_network_name }}
    #     run_diagnostics: ${{ inputs.summary_mode == 'full' }}
    #     diagnostics_fail_on_issues: 'false'
