# ============================================================================
# ACTION: SSH Django Deploy
# ============================================================================
# PURPOSE:
# Deploys a Django API application to a remote server via SSH using Podman.
# Handles server preparation, environment configuration, database setup, and
# background workers/schedulers.
#
# WHAT IT DOES:
# 1. Optionally prepares a fresh Ubuntu host (Podman, Traefik, directories)
# 2. Writes environment file to remote server
# 3. Logs in to container registry and pulls image
# 4. Runs Django migrations
# 5. Starts Django container with Traefik routing
# 6. Optionally starts database, worker, and scheduler containers
#
# WHEN TO USE:
# - Deploy Django API applications
# - Deploy to production, staging, or development environments
# - First deployment to a new server (set prepare_host: true)
# - Subsequent deployments (prepare_host: false)
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for complete guide
# ============================================================================

name: 'SSH Django Deploy'
description: 'Optionally prepare a fresh Ubuntu host, upload env, and deploy a Django container via Podman over SSH with Traefik routing support.'

# ============================================================================
# INPUTS - Organized by category
# ============================================================================
inputs:
  # ========================================================================
  # SSH / REMOTE EXECUTION
  # ========================================================================
  # Parameters for SSH connection to the remote server
  ssh_host:
    description: 'SSH host (IP or hostname). Required. Example: 192.168.1.100 or deploy.example.com'
    required: true
  ssh_user:
    description: 'SSH username to connect with (commands run as this user).'
    required: true
  ssh_key:
    description: 'SSH private key for authentication. Required. Should be stored as GitHub secret'
    required: true
  root_ssh_key:
    description: 'SSH private key for root (optional). Use if ssh_user is non-root but root access needed'
    required: false
  ssh_port:
    description: 'SSH port. Default: 22. Change if using non-standard SSH port'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Server SSH host key fingerprint for verification. Optional but recommended for security'
    required: false
  connect_mode:
    description: "Connection mode: 'auto', 'root', or 'user'. Default 'user' keeps commands under the SSH account."
    required: false
    default: 'user'

  # ========================================================================
  # HOST PREPARATION (OPTIONAL)
  # ========================================================================
  # Parameters for preparing a fresh Ubuntu host. Set prepare_host=true on first deployment
  prepare_host:
    description: 'Install Podman and prepare directories/users on a fresh Ubuntu host. Default: false'
    required: false
    default: 'false'
  install_podman:
    description: 'Install Podman when preparing host. Default: true'
    required: false
    default: 'true'
  install_traefik:
    description: 'Install Traefik when prepare_host runs. Default: true. Provides automatic HTTPS with Let''s Encrypt'
    required: false
    default: 'true'
  traefik_email:
    description: "Email for Traefik Let's Encrypt resolver. Required if install_traefik=true. Example: admin@example.com"
    required: false
  enable_traefik:
    description: 'Attach Traefik routing labels when a domain is available. Default: true'
    required: false
    default: 'true'
  env_dir_path:
    description: 'Directory to hold env files and app data on the server. Default: /var/deployments'
    required: false
  additional_packages:
    description: 'Space-separated additional apt packages for host preparation. Default: jq curl ca-certificates'
    required: false
    default: 'jq curl ca-certificates'

  # ========================================================================
  # ENVIRONMENT CONFIGURATION
  # ========================================================================
  # Parameters for environment file management and detection
  env_name:
    description: 'Environment name (production, staging, development). Auto-detected from branch if not provided'
    required: false
  auto_detect_env:
    description: 'Auto-detect environment name from branch when true. Default: true. See docs/ARCHITECTURE.md for rules'
    required: false
    default: 'true'
  env_file_path:
    description: 'Base directory on the server for env files. Final path: <env_file_path>/<env_name>/.env. Default: /var/deployments'
    required: false
  write_env_file:
    description: 'Write the env file on the server before deploy. Default: false. Set true to upload .env'
    required: false
    default: 'false'
  env_b64:
    description: 'Base64-encoded contents of the .env file. Create with: cat .env | base64'
    required: false
  env_content:
    description: 'Raw contents of the .env file. Use env_b64 instead when possible for security'
    required: false

  # ========================================================================
  # CONTAINER REGISTRY
  # ========================================================================
  # Parameters for Docker image registry and authentication
  registry:
    description: 'Container registry hostname. Default: ghcr.io (GitHub Container Registry)'
    required: false
    default: 'ghcr.io'
  image_name:
    description: 'Docker image name in org/repo format. Required. Example: myorg/myapp'
    required: true
  image_tag:
    description: 'Docker image tag to deploy. Auto-generated from commit SHA if not provided'
    required: false
  registry_username:
    description: 'Registry username. For ghcr.io use your GitHub username'
    required: false
  registry_token:
    description: 'Registry token/password. For ghcr.io can be PAT or GitHub token with package:write scope'
    required: false
  registry_login:
    description: 'Log in to registry before pulling image. Default: true'
    required: false
    default: 'true'

  # ========================================================================
  # CONTAINER RUNTIME
  # ========================================================================
  # Parameters for container execution and configuration
  app_slug:
    description: 'Slug used in default container name. Auto-derived from image_name if not provided'
    required: false
  container_name:
    description: 'Override container name. Default: ${app_slug}-${env_name}. Example: myapp-production'
    required: false
  host_port:
    description: 'Override host port. Default: from env file (API_HOST_PORT or PORT) or 8000'
    required: false
  container_port:
    description: 'Override container port. Default: from env file (API_CONTAINER_PORT or TARGET_PORT) or 8000'
    required: false
  restart_policy:
    description: 'Container restart policy. Default: unless-stopped. Options: no, always, on-failure, unless-stopped'
    required: false
    default: 'unless-stopped'
  migrate:
    description: 'Run Django migrations before starting container. Default: true'
    required: false
    default: 'true'
  migrate_cmd:
    description: 'Command to run migrations. Default: python manage.py migrate --noinput'
    required: false
    default: 'python manage.py migrate --noinput'
  extra_run_args:
    description: 'Additional arguments passed to podman run. Example: --cap-add NET_ADMIN'
    required: false
  memory_limit:
    description: 'Container memory limit. Default: 512m. Examples: 256m, 1g, 2g'
    required: false
    default: '512m'

  # ========================================================================
  # ENVIRONMENT SOURCING
  # ========================================================================
  # Parameters for environment file handling during deployment
  source_env:
    description: 'Source ENV_FILE prior to deploy commands. Default: true'
    required: false
    default: 'true'
  fail_if_env_missing:
    description: 'Fail if source_env is true and env file is missing. Default: true'
    required: false
    default: 'true'

  # ========================================================================
  # DOMAIN & ROUTING (TRAEFIK)
  # ========================================================================
  # Parameters for domain configuration and Traefik routing
  manage_vhost:
    description: '[Deprecated] Apache vhost management. Use Traefik instead. Default: false'
    required: false
    default: 'false'
  domain:
    description: 'Full domain to configure. Example: api.example.com. Overrides base_domain + prefix'
    required: false
  base_domain:
    description: 'Base domain used to compute domain. Example: example.com. Combined with prefix to create full domain'
    required: false
  domain_prefix_prod:
    description: 'Domain prefix for production environment. Default: api. Results in: api.example.com'
    required: false
    default: 'api'
  domain_prefix_staging:
    description: 'Domain prefix for staging environment. Default: api-staging. Results in: api-staging.example.com'
    required: false
    default: 'api-staging'
  domain_prefix_dev:
    description: 'Domain prefix for development environment. Default: api-dev. Results in: api-dev.example.com'
    required: false
    default: 'api-dev'
  vhost_mode:
    description: "[Deprecated] VHost mode: 'reverse_proxy' or 'mod_wsgi'. Default: mod_wsgi. Use Traefik instead"
    required: false
    default: 'mod_wsgi'
  wsgi_script_path:
    description: '[Deprecated] Path to wsgi.py on server when vhost_mode=mod_wsgi'
    required: false
  require_dns_match:
    description: '[Deprecated] Require domain A-record match to server public IP. Default: true'
    required: false
    default: 'true'

  # ========================================================================
  # DATABASE CONTAINER (OPTIONAL)
  # ========================================================================
  # Parameters for optional database container (PostgreSQL or MySQL)
  run_db:
    description: 'Run a database container before deploying the API. Default: false'
    required: false
    default: 'false'
  db_type:
    description: "Database type: 'postgres' or 'mysql'. Default: mysql"
    required: false
    default: 'mysql'
  db_service_name:
    description: 'Container name for DB service. Default: db-<app_slug>-<env_name>'
    required: false
  db_name:
    description: 'Database name. Example: myapp_db'
    required: false
  db_user:
    description: 'Database user. Example: myapp'
    required: false
  db_password:
    description: 'Database password. Should be stored as GitHub secret'
    required: false
  db_root_password:
    description: 'Root password (MySQL only). Should be stored as GitHub secret'
    required: false
  db_host_port:
    description: 'Host port to expose DB (optional). Example: 5432'
    required: false
  db_data_volume:
    description: 'Podman volume name or host path for DB data. Example: myapp-db-data'
    required: false
  db_image_tag:
    description: 'DB image tag. Default: postgres 16, mysql 8. Example: 15 or 5.7'
    required: false
  db_memory_limit:
    description: 'DB memory limit. Default: 512m. Examples: 256m, 1g'
    required: false
    default: '512m'

  # ========================================================================
  # BACKGROUND WORKER (OPTIONAL)
  # ========================================================================
  # Parameters for optional background worker container (e.g., Celery)
  run_worker:
    description: 'Run a background worker container. Default: false. Example: Celery worker'
    required: false
    default: 'false'
  worker_service_name:
    description: 'Worker container name. Default: worker-<app_slug>-<env_name>'
    required: false
  worker_command:
    description: 'Worker command to run inside the app image. Example: celery -A app worker -l info'
    required: false
  worker_image:
    description: 'Alternate image for worker. Default: uses API image'
    required: false
  worker_memory_limit:
    description: 'Worker memory limit. Default: 512m'
    required: false
    default: '512m'
  worker_volumes:
    description: 'Newline-separated list of volumes for the worker container'
    required: false

  # ========================================================================
  # SCHEDULER/CRON (OPTIONAL)
  # ========================================================================
  # Parameters for optional scheduler container (e.g., Celery Beat)
  run_scheduler:
    description: 'Run a scheduler/cron container. Default: false. Example: Celery Beat'
    required: false
    default: 'false'
  scheduler_service_name:
    description: 'Scheduler container name. Default: scheduler-<app_slug>-<env_name>'
    required: false
  scheduler_command:
    description: 'Scheduler command to run inside the app image. Example: celery -A app beat -l info'
    required: false
  scheduler_image:
    description: 'Alternate image for scheduler. Default: uses API image'
    required: false
  scheduler_memory_limit:
    description: 'Scheduler memory limit. Default: 512m'
    required: false
    default: '512m'
  scheduler_volumes:
    description: 'Newline-separated list of volumes for the scheduler container'
    required: false

# ============================================================================
# EXECUTION STEPS
# ============================================================================
# The deployment follows these steps:
# 1. Compute defaults - Calculate derived values (env_name, domain, etc.)
# 2. Validate inputs - Check required parameters
# 3. Prepare host (optional) - Install Podman, Traefik, create directories
# 4. Write env file (optional) - Upload .env to remote server
# 5. Login and pull image - Authenticate with registry and pull Docker image
# 6. Deploy Django App - Run migrations and start container
# 7. Run worker (optional) - Start background worker if enabled
# 8. Run scheduler (optional) - Start scheduler if enabled
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for detailed step explanations
# ============================================================================

runs:
  using: 'composite'
  steps:
    # ========================================================================
    # STEP 1: Compute derived defaults
    # ========================================================================
    # Calculates values that are derived from inputs (env_name, domain, etc.)
    # This step runs before validation to provide defaults for validation
    # ========================================================================
    - name: Compute derived defaults
      id: dfl
      uses: ./.github/actions/app/common/compute-defaults
      with:
        env_name: ${{ inputs.env_name }}
        auto_detect_env: ${{ inputs.auto_detect_env }}
        domain: ${{ inputs.domain }}
        base_domain: ${{ inputs.base_domain }}
        domain_prefix_prod: ${{ inputs.domain_prefix_prod }}
        domain_prefix_staging: ${{ inputs.domain_prefix_staging }}
        domain_prefix_dev: ${{ inputs.domain_prefix_dev }}

    - name: Validate inputs
      env:
        J_IMAGE_NAME: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}
      run: |
        set -euo pipefail
        if [ -z "${{ inputs.ssh_host }}" ]; then echo 'Error: ssh_host is required' ; exit 1 ; fi
        if [ -z "${{ inputs.ssh_key }}" ]; then echo 'Error: ssh_key is required' ; exit 1 ; fi
        if [ -z "${J_IMAGE_NAME}" ]; then echo 'Error: image_name is required' ; exit 1 ; fi
        if [ "${{ inputs.registry_login }}" = "true" ] && [ "${{ inputs.registry }}" != "ghcr.io" ]; then
          if [ -z "${{ inputs.registry_username }}" ] || [ -z "${{ inputs.registry_token }}" ]; then
            echo 'Error: registry_username and registry_token are required for non-GHCR registries when registry_login=true' ; exit 1
          fi
        fi
        if [ "${{ inputs.write_env_file }}" = "true" ]; then
          if [ -z "${{ inputs.env_b64 }}" ] && [ -z "${{ inputs.env_content }}" ]; then
            echo 'Error: write_env_file=true but neither env_b64 nor env_content provided' ; exit 1
          fi
        fi

        if [ "${{ inputs.install_traefik }}" = "true" ]; then
          TRAEFIK_EMAIL="${{ inputs.traefik_email != '' && inputs.traefik_email || (steps.dfl.outputs.domain_apex != '' && format('traefik@{0}', steps.dfl.outputs.domain_apex)) || '' }}"
          if [ -z "$TRAEFIK_EMAIL" ]; then
            echo 'Error: install_traefik=true but no traefik_email provided and no domain-derived default available.' ; exit 1
          fi
        fi
      shell: bash

    - name: Prepare host (optional)
      if: ${{ inputs.prepare_host == 'true' }}
      uses: ./.github/actions/infra/prepare-ubuntu-host
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        install_podman: ${{ inputs.install_podman }}
        install_traefik: ${{ inputs.install_traefik }}
        traefik_email: ${{ inputs.traefik_email != '' && inputs.traefik_email || (steps.dfl.outputs.domain_apex != '' && format('traefik@{0}', steps.dfl.outputs.domain_apex)) || '' }}
        env_dir_path: ${{ inputs.env_dir_path != '' && inputs.env_dir_path || steps.dfl.outputs.env_dir_path }}
        additional_packages: ${{ inputs.additional_packages }}

    - name: Write env file (optional)
      if: ${{ inputs.write_env_file == 'true' }}
      uses: ./.github/actions/app/write-remote-env-file
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}
        env_b64: ${{ inputs.env_b64 }}
        env_content: ${{ inputs.env_content }}

    - name: Login and pull image
      uses: ./.github/actions/podman/podman-login-pull
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        registry: ${{ inputs.registry }}
        registry_username: ${{ inputs.registry_username }}
        registry_token: ${{ inputs.registry_token }}
        registry_login: ${{ inputs.registry_login }}
        image_name: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}
        image_tag: ${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }}

    - name: Deploy Django App
      uses: ./.github/actions/podman/remote-podman-exec
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}
        source_env: ${{ inputs.source_env }}
        fail_if_env_missing: ${{ inputs.fail_if_env_missing }}
        inline_script: |
          set -euo pipefail

          ENV_BASE="${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}"
          ENV_NAME="${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}"
          ENV_DIR="${ENV_BASE%/}/$ENV_NAME"
          ENV_FILE="${REMOTE_ENV_FILE:-${ENV_DIR}/.env}"
          IMAGE="${{ inputs.registry }}/${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}:${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }}"

          CN_IN="${{ inputs.container_name }}"
          APP_SLUG="${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}"
          CONTAINER_NAME="${CN_IN:-${APP_SLUG}-${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}}"

          HP_IN="${{ inputs.host_port }}"
          CP_IN="${{ inputs.container_port }}"
          if [ -n "$HP_IN" ]; then
            HOST_PORT="$HP_IN"
          else
            HOST_PORT="${API_HOST_PORT:-${PORT:-8000}}"
          fi
          if [ -n "$CP_IN" ]; then
            CONTAINER_PORT="$CP_IN"
          else
            CONTAINER_PORT="${API_CONTAINER_PORT:-${TARGET_PORT:-8000}}"
          fi

          podman stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
          podman rm "$CONTAINER_NAME" >/dev/null 2>&1 || true

          if [ "${{ inputs.migrate }}" = "true" ]; then
            podman run --rm --env-file "$ENV_FILE" \
              "$IMAGE" \
              ${{ inputs.migrate_cmd }}
          fi

          EXTRA_ARGS="${{ inputs.extra_run_args }}"
          TRAEFIK_ENABLED="${{ inputs.enable_traefik }}"
          DOMAIN_INPUT="${{ inputs.domain }}"
          DOMAIN_DEFAULT="${{ steps.dfl.outputs.domain_default }}"
          DOMAIN="$DOMAIN_INPUT"
          if [ -z "$DOMAIN" ]; then DOMAIN="$DOMAIN_DEFAULT"; fi
          ROUTER="${{ steps.dfl.outputs.traefik_router }}"

          declare -a PORT_ARGS=()
          declare -a LABEL_ARGS=()

          if [ "$TRAEFIK_ENABLED" = "true" ] && [ -n "$DOMAIN" ]; then
            LABEL_ARGS+=(--label "traefik.enable=true")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.rule=Host(\`$DOMAIN\`)")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.entrypoints=websecure")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.tls.certresolver=letsencrypt")
            LABEL_ARGS+=(--label "traefik.http.services.${ROUTER}.loadbalancer.server.port=$CONTAINER_PORT")
          else
            PORT_ARGS=(-p "$HOST_PORT:$CONTAINER_PORT")
          fi

          podman run -d --name "$CONTAINER_NAME" --env-file "$ENV_FILE" \
            "${PORT_ARGS[@]}" \
            --restart=${{ inputs.restart_policy }} \
            --memory='${{ inputs.memory_limit }}' --memory-swap='${{ inputs.memory_limit }}' \
            ${EXTRA_ARGS:+$EXTRA_ARGS} \
            "${LABEL_ARGS[@]}" \
            "$IMAGE"

    - name: Run worker (optional)
      if: ${{ inputs.run_worker == 'true' }}
      uses: ./.github/actions/podman/podman-run-service
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        service_name: ${{ inputs.worker_service_name }}
        image: ${{ inputs.worker_image != '' && inputs.worker_image || format('{0}/{1}:{2}', inputs.registry, (inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name), inputs.image_tag) }}
        env_file: ${{ (inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path) }}${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}/.env
        command: ${{ inputs.worker_command }}
        restart_policy: unless-stopped
        memory_limit: ${{ inputs.worker_memory_limit }}
        volumes: ${{ inputs.worker_volumes }}

    - name: Run scheduler (optional)
      if: ${{ inputs.run_scheduler == 'true' }}
      uses: ./.github/actions/podman/podman-run-service
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        service_name: ${{ inputs.scheduler_service_name }}
        image: ${{ inputs.scheduler_image != '' && inputs.scheduler_image || format('{0}/{1}:{2}', inputs.registry, (inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name), (inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default)) }}
        env_file: ${{ (inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path) }}${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}/.env
        command: ${{ inputs.scheduler_command }}
        restart_policy: unless-stopped
        memory_limit: ${{ inputs.scheduler_memory_limit }}
        volumes: ${{ inputs.scheduler_volumes }}

