name: 'app: deployment-status-summary'
description: 'Generate a comprehensive deployment status summary (Podman, containers, pods, networks, listeners, HTTP probes, logs) into GITHUB_STEP_SUMMARY.'

inputs:
  reachable:
    description: 'Whether SSH host is reachable (from a previous probe)'
    required: true
  ssh_host:
    required: true
  ssh_user:
    required: true
  ssh_key:
    required: true
  ssh_port:
    required: false
    default: '22'
  app_slug:
    required: true
  env_name:
    required: true
  container_name:
    required: false
    default: ''
  enable_traefik:
    required: false
    default: 'true'
  domain_effective:
    required: false
    default: ''
  host_port:
    required: false
    default: '8080'
  container_port:
    required: false
    default: '8080'
  router_name:
    required: false
    default: ''
  whoami_probe:
    required: false
    default: 'false'
  traefik_network_name:
    required: false
    default: 'traefik-network'

  run_diagnostics:
    required: false
    default: 'true'
  diagnostics_skip_upload:
    required: false
    default: 'false'
  root_ssh_key:
    required: false
    default: ''
  traefik_container:
    required: false
    default: 'traefik'
  diagnostics_fail_on_issues:
    required: false
    default: 'true'
  diagnostics_attempt_auto_fix:
    required: false
    default: 'true'
  diagnostics_traefik_email:
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Server diagnostics (domain->container)
      if: ${{ inputs.reachable == 'true' && inputs.run_diagnostics == 'true' }}
      continue-on-error: true
      uses: ./.github/actions/infra/diagnose-routing
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        app_slug: ${{ inputs.app_slug }}
        env_name: ${{ inputs.env_name }}
        container_name: ${{ inputs.container_name }}
        domain_effective: ${{ inputs.domain_effective }}
        traefik_container: ${{ inputs.traefik_container }}
        host_port: ${{ inputs.host_port }}
        container_port: ${{ inputs.container_port }}
        skip_upload: ${{ inputs.diagnostics_skip_upload }}
        fail_on_issues: ${{ inputs.diagnostics_fail_on_issues }}
        attempt_auto_fix: ${{ inputs.diagnostics_attempt_auto_fix }}
        enable_traefik: ${{ inputs.enable_traefik }}
        traefik_network_name: ${{ inputs.traefik_network_name }}
        traefik_email: ${{ inputs.diagnostics_traefik_email }}

    - name: Deployment status summary
      if: ${{ inputs.reachable == 'true' }}
      shell: bash
      env:
        SSH_HOST: ${{ inputs.ssh_host }}
        SSH_USER: ${{ inputs.ssh_user }}
        SSH_KEY: ${{ inputs.ssh_key }}
        SSH_PORT: ${{ inputs.ssh_port }}
        APP_SLUG: ${{ inputs.app_slug }}
        ENV_NAME: ${{ inputs.env_name }}
        CONTAINER_NAME_IN: ${{ inputs.container_name }}
        TRAEFIK_ENABLED: ${{ inputs.enable_traefik }}
        DOMAIN_EFFECTIVE: ${{ inputs.domain_effective }}
        HOST_PORT_IN: ${{ inputs.host_port }}
        CONTAINER_PORT_IN: ${{ inputs.container_port }}
        ROUTER_NAME_IN: ${{ inputs.router_name }}
        WHOAMI_PROBE: ${{ inputs.whoami_probe }}
        TRAEFIK_NETWORK_NAME: ${{ inputs.traefik_network_name }}
      run: |
        set -euo pipefail

        KEY_FILE="$(mktemp)"
        trap "rm -f '$KEY_FILE'" EXIT
        if printf '%s' "$SSH_KEY" | grep -q '\\n'; then
          printf '%s\n' "$SSH_KEY" | sed 's/\\n/\n/g' > "$KEY_FILE"
        else
          printf '%s\n' "$SSH_KEY" > "$KEY_FILE"
        fi
        chmod 600 "$KEY_FILE"

        ENV_CANON=$(printf '%s' "$ENV_NAME" | tr '[:upper:]' '[:lower:]')
        if [ -n "$CONTAINER_NAME_IN" ]; then
          CONT_NAME="$CONTAINER_NAME_IN"
        else
          CONT_NAME="${APP_SLUG}-${ENV_CANON}"
        fi
        HOST_PORT="$HOST_PORT_IN"
        CONT_PORT="$CONTAINER_PORT_IN"
        ROUTER_NAME="$ROUTER_NAME_IN"

        if [ "${TRAEFIK_ENABLED}" = "true" ] && [ -n "${DOMAIN_EFFECTIVE}" ]; then
          URL_LABEL="https://${DOMAIN_EFFECTIVE}"
        else
          URL_LABEL="http://${SSH_HOST}:${HOST_PORT}"
        fi

        SSH_BASE=(ssh -i "$KEY_FILE" -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=8 -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}")

        DNS_PUBLIC_RECORDS="(skipped)"
        DNS_AUTH_RECORDS="(skipped)"
        DNS_AUTHORITY="(skipped)"
        DNS_MATCH_STATUS="(not evaluated)"
        REMOTE_IPV4="unknown"
        if [ "${TRAEFIK_ENABLED}" = "true" ] && [ -n "${DOMAIN_EFFECTIVE}" ]; then
          if command -v dig >/dev/null 2>&1; then
            DNS_PUBLIC_RECORDS=$(dig +short "${DOMAIN_EFFECTIVE}" 2>/dev/null | tr '\n' ' ' | sed 's/ *$//')
            DNS_AUTHORITY=$(dig +short NS "${DOMAIN_EFFECTIVE}" 2>/dev/null | head -1 | sed 's/\.$//')
            if [ -n "$DNS_AUTHORITY" ]; then
              DNS_AUTH_RECORDS=$(dig +short @"$DNS_AUTHORITY" "${DOMAIN_EFFECTIVE}" 2>/dev/null | tr '\n' ' ' | sed 's/ *$//')
            else
              DNS_AUTH_RECORDS="(no NS records found)"
            fi
          else
            DNS_PUBLIC_RECORDS="(dig unavailable on runner)"
            DNS_AUTH_RECORDS="(dig unavailable on runner)"
            DNS_AUTHORITY="(dig unavailable)"
          fi

          REMOTE_IPV4=$(${SSH_BASE[@]} "hostname -I 2>/dev/null | awk '{print \$1}'" 2>/dev/null || echo "unknown")
          if [ -z "$REMOTE_IPV4" ]; then
            REMOTE_IPV4="unknown"
          fi

          if [ "$REMOTE_IPV4" = "unknown" ]; then
            DNS_MATCH_STATUS="unknown (remote host IP unavailable)"
          else
            FOUND_MATCH="no"
            for candidate in $DNS_PUBLIC_RECORDS $DNS_AUTH_RECORDS; do
              if [ -n "$candidate" ] && [ "$candidate" = "$REMOTE_IPV4" ]; then
                FOUND_MATCH="yes"
                break
              fi
            done
            if [ "$FOUND_MATCH" = "yes" ]; then
              DNS_MATCH_STATUS="✅ Records include remote IP ${REMOTE_IPV4}"
            else
              DNS_MATCH_STATUS="⚠️ DNS resolves to [$DNS_PUBLIC_RECORDS] (auth: [$DNS_AUTH_RECORDS]); remote host IP is ${REMOTE_IPV4}"
            fi
          fi
        fi

        # Privilege visibility
        CURRENT_USER="$(${SSH_BASE[@]} 'whoami' 2>/dev/null || echo 'unknown')"
        CURRENT_UID="$(${SSH_BASE[@]} 'id -u' 2>/dev/null || echo 'unknown')"
        HAS_SUDO="no"
        if ${SSH_BASE[@]} 'sudo -n true' 2>/dev/null; then
          HAS_SUDO="yes"
        fi

        echo "::notice::Remote session user: ${CURRENT_USER} (uid:${CURRENT_UID}, sudo:${HAS_SUDO})"
        if [ "$CURRENT_USER" = "root" ]; then
          echo "::warning::Remote commands are executing as root; verify this is intended." >&2
        fi

        # Sanitization helper
        sanitize_output() {
          printf '%s\n' "$1" | sed 's/password=[^ ]*//gi; s/token=[^ ]*//gi; s/secret=[^ ]*//gi; s/key=[^ ]*//gi'
        }

        PODMAN_VERSION="$(${SSH_BASE[@]} 'podman --version' 2>/dev/null || echo "unavailable")"
        CONTAINERS_TBL="$(${SSH_BASE[@]} "podman ps -a --format 'table {{.ID}}\t{{.Status}}\t{{.Names}}\t{{.Ports}}\t{{.Image}}'" 2>/dev/null || echo "unavailable")"
        PODS_TBL="$(${SSH_BASE[@]} "podman pod ps -a --format 'table {{.ID}}\t{{.Status}}\t{{.Name}}\t{{.Networks}}'" 2>/dev/null || echo "unavailable")"
        NETWORKS_TBL="$(${SSH_BASE[@]} "podman network ls --format 'table {{.Name}}\t{{.Driver}}\t{{.Labels}}'" 2>/dev/null || echo "unavailable")"
        LISTENERS="$(${SSH_BASE[@]} "ss -ltnp 2>/dev/null | head -n 80 || netstat -ltnp 2>/dev/null | head -n 80" 2>/dev/null || echo "unavailable")"

        CONT_PRESENT=$(${SSH_BASE[@]} "podman ps -a --format '{{.Names}}' | grep -Fx '${CONT_NAME}' >/dev/null && echo yes || echo no" 2>/dev/null || echo no)

        HTTP_STATUS_DOMAIN="N/A"
        DOMAIN_TIMING="N/A"
        DOMAIN_PROTO="N/A"
        if [ "${TRAEFIK_ENABLED}" = "true" ] && [ -n "${DOMAIN_EFFECTIVE}" ]; then
          HTTP_STATUS_DOMAIN="$(${SSH_BASE[@]} "curl -ksS -o /dev/null -w '%{http_code}' --max-time 10 'https://${DOMAIN_EFFECTIVE}'" 2>/dev/null || echo "ERR")"
          # Capture timing and HTTP version (best-effort)
          DOMAIN_TIMING="$(${SSH_BASE[@]} "curl -ksS -o /dev/null -w '%{time_total}' --max-time 10 'https://${DOMAIN_EFFECTIVE}'" 2>/dev/null || echo "N/A")"
          DOMAIN_PROTO="$(${SSH_BASE[@]} "curl -ksS -o /dev/null -w 'HTTP/%{http_version}' --max-time 10 'https://${DOMAIN_EFFECTIVE}'" 2>/dev/null || echo "N/A")"
          # Runner-side probe to seed access logs with an external client and capture headers
          RUNNER_HTTP_STATUS_DOMAIN=$(curl -ksS -o /dev/null -w '%{http_code}' --max-time 10 "https://${DOMAIN_EFFECTIVE}" || echo "ERR")
          RUNNER_DOMAIN_TIMING=$(curl -ksS -o /dev/null -w '%{time_total}' --max-time 10 "https://${DOMAIN_EFFECTIVE}" || echo "N/A")
          RUNNER_HEADERS=$(curl -ksSI --max-time 10 "https://${DOMAIN_EFFECTIVE}" 2>/dev/null || true)
          HDR_XFF=$(printf '%s\n' "$RUNNER_HEADERS" | grep -i '^X-Forwarded-For:' | head -n1 | sed 's/^X-Forwarded-For:[[:space:]]*//I')
          HDR_XRI=$(printf '%s\n' "$RUNNER_HEADERS" | grep -i '^X-Real-Ip:' | head -n1 | sed 's/^X-Real-Ip:[[:space:]]*//I')
          HDR_FWD=$(printf '%s\n' "$RUNNER_HEADERS" | grep -i '^Forwarded:' | head -n1 | sed 's/^Forwarded:[[:space:]]*//I')
        fi
        HTTP_STATUS_PORT="$(${SSH_BASE[@]} "curl -fsS -o /dev/null -w '%{http_code}' --max-time 5 'http://127.0.0.1:${HOST_PORT}'" 2>/dev/null || echo "ERR")"

        IN_CONTAINER_PROBE="N/A"
        if [ "$CONT_PRESENT" = "yes" ]; then
          IN_CONTAINER_PROBE="$(${SSH_BASE[@]} "podman exec '${CONT_NAME}' sh -lc 'if command -v curl >/dev/null 2>&1; then curl -fsS -o /dev/null -w \"%{http_code}\" http://127.0.0.1:${CONT_PORT} --max-time 5; elif command -v wget >/dev/null 2>&1; then wget -qO- --server-response http://127.0.0.1:${CONT_PORT} 2>&1 | awk \"/HTTP\/{print \$2; exit}\"; else echo NO_CURL_WGET; fi'" 2>/dev/null || echo "ERR")"
        fi

        # App container routing context: labels and networks
        APP_LABELS=""
        APP_NETWORKS=""
        TRAEFIK_NETWORKS=""
        NETWORK_JOIN_CHECK="unknown"
        IN_CONTAINER_LISTENERS=""
        if [ "$CONT_PRESENT" = "yes" ]; then
          APP_LABELS=$(${SSH_BASE[@]} "podman inspect -f '{{ range $k, $v := .Config.Labels }}{{ $k }}={{ $v }}{{ printf \"\\n\" }}{{ end }}' '${CONT_NAME}' 2>/dev/null | grep '^traefik\.' || true" 2>/dev/null || echo "")
          APP_NETWORKS=$(${SSH_BASE[@]} "podman inspect -f '{{ range $k, $v := .NetworkSettings.Networks }}{{ $k }} {{ end }}' '${CONT_NAME}' 2>/dev/null | sed 's/ *$//'" 2>/dev/null || echo "")
          TRAEFIK_NETWORKS=$(${SSH_BASE[@]} "podman inspect -f '{{ range $k, $v := .NetworkSettings.Networks }}{{ $k }} {{ end }}' traefik 2>/dev/null | sed 's/ *$//'" 2>/dev/null || echo "")
          IN_CONTAINER_LISTENERS=$(${SSH_BASE[@]} "podman exec '${CONT_NAME}' sh -lc 'ss -ltnp 2>/dev/null | head -n 60 || netstat -ltnp 2>/dev/null | head -n 60'" 2>/dev/null || echo "")
          if printf '%s' "$APP_NETWORKS" | grep -qw "${TRAEFIK_NETWORK_NAME}" && printf '%s' "$TRAEFIK_NETWORKS" | grep -qw "${TRAEFIK_NETWORK_NAME}"; then
            NETWORK_JOIN_CHECK="✅ both containers on ${TRAEFIK_NETWORK_NAME}"
          else
            NETWORK_JOIN_CHECK="⚠️ check networks: app=[${APP_NETWORKS:-none}] traefik=[${TRAEFIK_NETWORKS:-none}]"
          fi
        fi

        RECENT_LOGS=""
        if [ "$CONT_PRESENT" = "yes" ]; then
          RECENT_LOGS="$(${SSH_BASE[@]} "podman logs --tail 80 '${CONT_NAME}' 2>/dev/null" || true)"
        fi

        # Traefik access logs: prefer container logs, fallback to journal (quadlet)
        TRA_LOG_SRC="none"
        TRAEFIK_LOGS=""
        TRAEFIK_CONT_EXISTS=$(${SSH_BASE[@]} "podman container exists traefik >/dev/null 2>&1 && echo yes || echo no" 2>/dev/null || echo no)
        if [ "$TRAEFIK_CONT_EXISTS" = "yes" ]; then
          TRAEFIK_LOGS="$(${SSH_BASE[@]} "podman logs --tail 200 traefik 2>/dev/null" || true)"
          if [ -n "$TRAEFIK_LOGS" ]; then TRA_LOG_SRC="container"; fi
        fi
        if [ -z "$TRAEFIK_LOGS" ]; then
          JLOGS="$(${SSH_BASE[@]} "journalctl --user -u traefik -n 200 --no-pager 2>/dev/null" || true)"
          if [ -n "$JLOGS" ]; then
            TRAEFIK_LOGS="$JLOGS"
            TRA_LOG_SRC="journal"
          fi
        fi

        CLIENT_IPS=""
        if [ -n "$TRAEFIK_LOGS" ]; then
          CLIENT_IPS=$(printf '%s\n' "$TRAEFIK_LOGS" | grep -Eo '([0-9]{1,3}[.]){3}[0-9]{1,3}' | grep -v '^127\.0\.0\.1$' | tail -n 200 | sort -u | tr '\n' ' ' | sed 's/ *$//')
        fi

        now_utc=$(date -u +'%Y-%m-%d %H:%M:%S UTC')

        {
          echo "# Deployment Status Summary"
          echo
          echo "- **App**: ${APP_SLUG}"
          echo "- **Environment**: ${ENV_CANON}"
          echo "- **Container name**: ${CONT_NAME}"
          echo "- **Endpoint**: ${URL_LABEL}"
          echo "- **SSH Host**: ${SSH_HOST}"
          echo "- **Generated**: ${now_utc}"
          echo
          echo "## Podman Version"
          echo
          echo '```'
          echo "$PODMAN_VERSION"
          echo '```'
          echo
          echo "## Containers"
          echo
          echo '```'
          echo "$CONTAINERS_TBL"
          echo '```'
          echo
          echo "## Pods"
          echo
          echo '```'
          echo "$PODS_TBL"
          echo '```'
          echo
          echo "## Networks"
          echo
          echo '```'
          echo "$NETWORKS_TBL"
          echo '```'
          echo
          echo "## Network Listeners (Top 80)"
          echo
          echo '```'
          sanitize_output "$LISTENERS"
          echo '```'
          echo
          echo "## Endpoint Checks"
          echo
          echo "- **Traefik URL**: ${DOMAIN_EFFECTIVE:-N/A} → ${HTTP_STATUS_DOMAIN}"
          if [ -n "${DOMAIN_EFFECTIVE}" ] && [ "${HTTP_STATUS_DOMAIN}" != "N/A" ]; then
            echo "- **Traefik Timing/Proto**: ${DOMAIN_TIMING}s, ${DOMAIN_PROTO}"
          fi
          echo "- **Host Port**: 127.0.0.1:${HOST_PORT} → ${HTTP_STATUS_PORT}"
          echo "- **In-Container Probe**: 127.0.0.1:${CONT_PORT} inside ${CONT_NAME} → ${IN_CONTAINER_PROBE}"
          if [ -n "${DOMAIN_EFFECTIVE}" ]; then
            echo "- **Runner → Domain**: https://${DOMAIN_EFFECTIVE} → ${RUNNER_HTTP_STATUS_DOMAIN} (${RUNNER_DOMAIN_TIMING}s)"
            if [ -n "$HDR_XFF$HDR_XRI$HDR_FWD" ]; then
              echo "  - **Headers**:"
              if [ -n "$HDR_XFF" ]; then echo "    - X-Forwarded-For: ${HDR_XFF}"; fi
              if [ -n "$HDR_XRI" ]; then echo "    - X-Real-Ip: ${HDR_XRI}"; fi
              if [ -n "$HDR_FWD" ]; then echo "    - Forwarded: ${HDR_FWD}"; fi
            else
              echo "  - **Headers**: (no X-Forwarded-For/X-Real-Ip/Forwarded provided by app)"
            fi
          fi
          echo
          if [ -n "$ROUTER_NAME" ]; then
            echo "## Traefik API (best-effort)"
            echo
            TRAEFIK_API_CODE=$(${SSH_BASE[@]} "curl -fsS -o /dev/null -w '%{http_code}' --max-time 4 http://127.0.0.1:8080/api/http/routers" 2>/dev/null || echo "ERR")
            echo "- **API /http/routers**: ${TRAEFIK_API_CODE}"
            if [ "$TRAEFIK_API_CODE" = "200" ]; then
              # Try to detect router presence for this app
              ROUTER_MATCH=$(${SSH_BASE[@]} "curl -fsS --max-time 4 http://127.0.0.1:8080/api/http/routers 2>/dev/null | tr -d '\n' | grep -o '"name":"[^\"]*"' | grep -c '\\"${ROUTER_NAME}@docker\\"'" 2>/dev/null || echo 0)
              if [ "${ROUTER_MATCH:-0}" -gt 0 ]; then
                echo "- **Router presence**: ${ROUTER_NAME}@docker found"
              else
                echo "- **Router presence**: ${ROUTER_NAME}@docker not found"
              fi
              SERVICE_MATCH=$(${SSH_BASE[@]} "curl -fsS --max-time 4 http://127.0.0.1:8080/api/http/services 2>/dev/null | tr -d '\n' | grep -o '"name":"[^\"]*"' | grep -c '\\"${ROUTER_NAME}@docker\\"'" 2>/dev/null || echo 0)
              if [ "${SERVICE_MATCH:-0}" -gt 0 ]; then
                echo "- **Service presence**: ${ROUTER_NAME}@docker found"
              else
                echo "- **Service presence**: ${ROUTER_NAME}@docker not found"
              fi
            elif [ "$TRAEFIK_API_CODE" = "401" ]; then
              echo "- **Note**: API reachable but requires auth (dashboard protected)."
            else
              echo "- **Note**: API not reachable (dashboard not exposed)."
            fi
            echo
          fi
          echo "## Container Routing Diagnostics"
          echo
          echo "- **Network join**: ${NETWORK_JOIN_CHECK}"
          if [ -n "$APP_NETWORKS$TRAEFIK_NETWORKS" ]; then
            echo "- **App networks**: ${APP_NETWORKS:-none}"
            echo "- **Traefik networks**: ${TRAEFIK_NETWORKS:-none}"
          fi
          if [ -n "$APP_LABELS" ]; then
            echo
            echo "### App Traefik Labels"
            echo
            echo '```'
            sanitize_output "$APP_LABELS"
            echo '```'
          fi
          if [ -n "$IN_CONTAINER_LISTENERS" ]; then
            echo
            echo "### In-Container Listeners (Top 60)"
            echo
            echo '```'
            sanitize_output "$IN_CONTAINER_LISTENERS"
            echo '```'
          fi
          if [ "${TRAEFIK_ENABLED}" = "true" ] && [ -n "${DOMAIN_EFFECTIVE}" ]; then
            echo "## DNS Diagnostics"
            echo
            echo "- **Public resolvers**: ${DNS_PUBLIC_RECORDS}"
            if [ -n "$DNS_AUTHORITY" ]; then
              echo "- **Authoritative NS** (${DNS_AUTHORITY:-unknown}): ${DNS_AUTH_RECORDS}"
            else
              echo "- **Authoritative NS**: ${DNS_AUTH_RECORDS}"
            fi
            echo "- **Remote host IPv4**: ${REMOTE_IPV4}"
            echo "- **Match status**: ${DNS_MATCH_STATUS}"
            echo
          fi

          # Optional whoami probe (ephemeral) under PathPrefix /__whoami
          if [ "${TRAEFIK_ENABLED}" = "true" ] && [ -n "${DOMAIN_EFFECTIVE}" ] && [ "${WHOAMI_PROBE}" = "true" ]; then
            echo "## Traefik whoami Probe" 
            echo
            WHOAMI_NAME="whoami-probe-${ENV_CANON}"
            WHOAMI_ROUTER="whoami-${ENV_CANON}"
            # Clean up any stale instance
            ${SSH_BASE[@]} "podman rm -f '$WHOAMI_NAME' >/dev/null 2>&1 || true" >/dev/null 2>&1 || true
            # Build labels: Host(`domain`) && PathPrefix(`/__whoami`)
            L1="traefik.enable=true"
            L2="traefik.http.routers.${WHOAMI_ROUTER}.rule=Host(\`${DOMAIN_EFFECTIVE}\`) && PathPrefix(\`/__whoami\`)"
            L3="traefik.http.routers.${WHOAMI_ROUTER}.entrypoints=websecure,web"
            L4="traefik.http.routers.${WHOAMI_ROUTER}.tls.certresolver=letsencrypt"
            L5="traefik.http.services.${WHOAMI_ROUTER}.loadbalancer.server.port=80"
            # Start ephemeral whoami container
            ${SSH_BASE[@]} "podman run -d --name '$WHOAMI_NAME' --network '${TRAEFIK_NETWORK_NAME}' \
              --label '$L1' --label '$L2' --label '$L3' --label '$L4' --label '$L5' \
              docker.io/traefik/whoami:v1.10.1" >/dev/null 2>&1 || true
            # Probe
            PROBE_CODE=""
            PROBE_BODY=""
            for i in 1 2 3 4 5; do
              PROBE_CODE=$(curl -ksS -o /dev/null -w '%{http_code}' --max-time 8 "https://${DOMAIN_EFFECTIVE}/__whoami" || echo "000")
              if [ "$PROBE_CODE" -ge 200 ] && [ "$PROBE_CODE" -lt 400 ]; then break; fi
              sleep 2
            done
            if [ "$PROBE_CODE" -ge 200 ] && [ "$PROBE_CODE" -lt 400 ]; then
              PROBE_BODY=$(curl -ksSL --max-time 8 "https://${DOMAIN_EFFECTIVE}/__whoami" 2>/dev/null | head -n 80 || true)
              echo "- **Status**: ✅ ${PROBE_CODE}"
              # Extract key lines
              W_REMOTE=$(printf '%s\n' "$PROBE_BODY" | grep -i '^RemoteAddr:' | head -n1 | sed 's/^RemoteAddr:[[:space:]]*//')
              W_XFF=$(printf '%s\n' "$PROBE_BODY" | grep -i '^X-Forwarded-For:' | head -n1 | sed 's/^X-Forwarded-For:[[:space:]]*//I')
              W_XRI=$(printf '%s\n' "$PROBE_BODY" | grep -i '^X-Real-Ip:' | head -n1 | sed 's/^X-Real-Ip:[[:space:]]*//I')
              echo "  - RemoteAddr: ${W_REMOTE:-unknown}"
              if [ -n "$W_XFF$W_XRI" ]; then
                if [ -n "$W_XFF" ]; then echo "  - X-Forwarded-For: ${W_XFF}"; fi
                if [ -n "$W_XRI" ]; then echo "  - X-Real-Ip: ${W_XRI}"; fi
              fi
            else
              echo "- **Status**: ❌ ${PROBE_CODE}"
            fi
            # Cleanup
            ${SSH_BASE[@]} "podman rm -f '$WHOAMI_NAME' >/dev/null 2>&1 || true" >/dev/null 2>&1 || true
            echo
          fi

          if [ -n "$RECENT_LOGS" ]; then
            echo "## Recent Container Logs (${CONT_NAME})"
            echo
            echo '```'
            sanitize_output "$RECENT_LOGS"
            echo '```'
            echo
          fi

          if [ -n "$TRAEFIK_LOGS" ]; then
            echo "## Traefik Access Logs (last 200) [source: ${TRA_LOG_SRC}]"
            echo
            if [ -n "$CLIENT_IPS" ]; then
              echo "- **Client IPs seen**: ${CLIENT_IPS}"
              echo
            fi
            echo '```'
            sanitize_output "$TRAEFIK_LOGS"
            echo '```'
            echo
          else
            echo "## Traefik Access Logs"
            echo
            echo "- **Note**: No Traefik logs captured (container and journal sources empty)."
            echo
          fi
        } >> "$GITHUB_STEP_SUMMARY"

    - name: Fail on diagnostics issues (after summary)
      if: ${{ always() && inputs.reachable == 'true' && inputs.run_diagnostics == 'true' && inputs.diagnostics_fail_on_issues == 'true' }}
      shell: bash
      env:
        SSH_HOST: ${{ inputs.ssh_host }}
        SSH_USER: ${{ inputs.ssh_user }}
        SSH_KEY: ${{ inputs.ssh_key }}
        SSH_PORT: ${{ inputs.ssh_port }}
        DOMAIN_EFFECTIVE: ${{ inputs.domain_effective }}
      run: |
        set -euo pipefail
        KEY_FILE="$(mktemp)"
        trap "rm -f '$KEY_FILE'" EXIT
        if printf '%s' "$SSH_KEY" | grep -q '\\n'; then
          printf '%s\n' "$SSH_KEY" | sed 's/\\n/\n/g' > "$KEY_FILE"
        else
          printf '%s\n' "$SSH_KEY" > "$KEY_FILE"
        fi
        chmod 600 "$KEY_FILE"
        LOG_FILE="$RUNNER_TEMP/uactions_diag_tail_final.log"
        ssh -i "$KEY_FILE" -o StrictHostKeyChecking=no -o ConnectTimeout=10 -p "${SSH_PORT:-22}" "$SSH_USER@$SSH_HOST" \
          "tail -n 250 /tmp/uactions_diag_latest.log 2>/dev/null" > "$LOG_FILE" 2>/dev/null || true

        FAIL_REASONS=()
        if [ -s "$LOG_FILE" ]; then
          if grep -qE '^Traefik container:\s*FAIL' "$LOG_FILE"; then FAIL_REASONS+=("Traefik container missing"); fi
          if grep -qE '^App container:\s*FAIL' "$LOG_FILE"; then FAIL_REASONS+=("App container missing"); fi
          if [ -n "${DOMAIN_EFFECTIVE}" ]; then
            if grep -qE '^80/443 listeners:\s*FAIL' "$LOG_FILE"; then FAIL_REASONS+=("No listeners on 80/443 while domain is set"); fi
            if grep -qE '^DNS matches server IP:\s*(mismatch|unknown)' "$LOG_FILE"; then FAIL_REASONS+=("DNS does not match server public IP"); fi
          fi
        else
          # No log: do not fail here; summary already explains reachability
          exit 0
        fi

        if [ ${#FAIL_REASONS[@]} -gt 0 ]; then
          for r in "${FAIL_REASONS[@]}"; do
            echo "::error::Diagnostics: ${r}"
          done
          exit 1
        fi

    - name: Deployment summary (unreachable)
      if: ${{ inputs.reachable != 'true' }}
      shell: bash
      run: |
        echo "# Deployment Status Summary" >> "$GITHUB_STEP_SUMMARY"
        echo >> "$GITHUB_STEP_SUMMARY"
        echo "- **Status**: SSH host not reachable; no remote status available." >> "$GITHUB_STEP_SUMMARY"
        echo "- **Tip**: Verify firewall (UFW/security group), host/port, and credentials." >> "$GITHUB_STEP_SUMMARY"
