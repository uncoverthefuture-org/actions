# ============================================================================
# ACTION: SSH Django API Deploy
# ============================================================================
# PURPOSE:
# Deploys a Django API application to a remote server via SSH using Podman.
# [DEPRECATED] - Use ssh-django-deploy instead. This action uses Apache vhost.
#
# WHAT IT DOES:
# 1. Optionally prepares a fresh Ubuntu host (Podman, Apache, directories)
# 2. Writes environment file to remote server
# 3. Logs in to container registry and pulls image
# 4. Runs Django migrations
# 5. Starts Django container with Apache vhost routing
# 6. Optionally starts database, worker, and scheduler containers
#
# WHEN TO USE:
# - Deploy Django API applications (legacy Apache setup)
# - Prefer ssh-django-deploy for new deployments (uses Traefik)
# - Deploy to production, staging, or development environments
#
# DEPRECATION NOTE:
# This action uses Apache vhost management which is deprecated.
# New deployments should use ssh-django-deploy with Traefik instead.
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for complete guide
# ============================================================================

name: 'SSH Django API Deploy'
description: 'Optionally prepare a fresh Ubuntu host, upload env, and deploy a Django API container via Podman over SSH with Traefik routing support.'

# ============================================================================
# INPUTS - Organized by category (similar to ssh-django-deploy)
# ============================================================================
inputs:
  # ========================================================================
  # SSH / REMOTE EXECUTION
  # ========================================================================
  ssh_host:
    description: 'SSH host'
    required: true
  ssh_user:
    description: 'SSH username to connect with (commands run as this user).'
    required: true
  ssh_key:
    description: 'SSH private key for non-root user'
    required: true
  root_ssh_key:
    description: 'SSH private key for root (optional)'
    required: false
  ssh_port:
    description: 'SSH port'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Server SSH host key fingerprint to verify host identity (optional but recommended)'
    required: false
  connect_mode:
    description: "How to connect: 'auto', 'root', or 'user'. Default 'user' keeps commands under SSH user."
    required: false
    default: 'user'

  # Prepare host (optional)
  prepare_host:
    description: 'Install Podman and prepare directories/users on a fresh Ubuntu host'
    required: false
    default: 'false'
  install_podman:
    description: 'Install Podman when preparing host'
    required: false
    default: 'true'
  install_traefik:
    description: 'Install Traefik when prepare_host runs'
    required: false
    default: 'true'
  traefik_email:
    description: "Email used for Traefik Let's Encrypt resolver (required if install_traefik=true)"
    required: false
  enable_traefik:
    description: 'Attach Traefik routing labels when a domain is available'
    required: false
    default: 'true'
  env_dir_path:
    description: 'Directory to hold env files and app data on the server'
    required: false
  additional_packages:
    description: 'Space-separated additional apt packages for host preparation'
    required: false
    default: 'jq curl ca-certificates'

  # Environment file
  env_name:
    description: 'Environment name used to build container and env file path'
    required: false
  auto_detect_env:
    description: 'Auto-detect environment name from branch when true'
    required: false
    default: 'true'
  env_file_path:
    description: 'Base directory on the server; the final file is <env_file_path>/<env_name>/.env'
    required: false
  write_env_file:
    description: 'If true, write the env file on the server before deploy'
    required: false
    default: 'false'
  env_b64:
    description: 'Base64-encoded contents of the .env file to write on the server'
    required: false
  env_content:
    description: 'Raw contents of the .env file to write on the server (use env_b64 instead when possible)'
    required: false

  # Image/registry
  registry:
    description: 'Container registry hostname'
    required: false
    default: 'ghcr.io'
  image_name:
    description: 'Image name (e.g., org/app)'
    required: true
  image_tag:
    description: 'Image tag to deploy'
    required: false
  registry_username:
    description: 'Registry username (for ghcr.io use your GH username)'
    required: false
  registry_token:
    description: 'Registry token/password (for ghcr.io can be a PAT or GitHub token with package:write)'
    required: false
  registry_login:
    description: 'Log in to registry before pulling image'
    required: false
    default: 'true'

  # Runtime
  app_slug:
    description: 'Slug used in default container name'
    required: false
  container_name:
    description: 'Override container name (defaults to ${app_slug}-${env_name})'
    required: false
  host_port:
    description: 'Override host port (default is derived from env file: API_HOST_PORT or PORT, else 8000)'
    required: false
  container_port:
    description: 'Override container port (default derived from env file: API_CONTAINER_PORT or TARGET_PORT, else 8000)'
    required: false
  restart_policy:
    description: 'Container restart policy'
    required: false
    default: 'unless-stopped'
  migrate:
    description: 'Run Django migrations before starting the container'
    required: false
    default: 'true'
  migrate_cmd:
    description: 'Command to run migrations'
    required: false
    default: 'python manage.py migrate --noinput'
  extra_run_args:
    description: 'Additional args passed to podman run'
    required: false
  memory_limit:
    description: 'Container memory limit, e.g., 512m'
    required: false
    default: '512m'

  # Env sourcing for deployment
  source_env:
    description: 'Source ENV_FILE prior to deploy commands'
    required: false
    default: 'true'
  fail_if_env_missing:
    description: 'Fail if source_env is true and env file is missing'
    required: false
    default: 'true'

  # Apache vhost management (optional)
  manage_vhost:
    description: '[Deprecated] Apache vhost management is disabled in favor of Traefik'
    required: false
    default: 'false'
  domain:
    description: 'Full domain to configure (optional)'
    required: false
  base_domain:
    description: 'Base domain used to compute domain if domain is not provided'
    required: false
  domain_prefix_prod:
    description: 'Domain prefix for production/main env'
    required: false
    default: 'api'
  domain_prefix_staging:
    description: 'Domain prefix for staging env'
    required: false
    default: 'api-staging'
  domain_prefix_dev:
    description: 'Domain prefix for dev env'
    required: false
    default: 'api-dev'
  vhost_mode:
    description: "VHost mode: 'reverse_proxy' (default) or 'mod_wsgi'"
    required: false
    default: 'reverse_proxy'
  wsgi_script_path:
    description: 'Path to wsgi.py on server when vhost_mode=mod_wsgi'
    required: false
  require_dns_match:
    description: 'Require domain A-record match to server public IP before applying changes'
    required: false
    default: 'true'

  # Optional DB container
  run_db:
    description: 'Run a database container before deploying the API'
    required: false
    default: 'false'
  db_type:
    description: "Database type: 'postgres' or 'mysql'"
    required: false
    default: 'mysql'
  db_service_name:
    description: 'Container name for DB service (default: db-<app_slug>-<env_name>)'
    required: false
  db_name:
    description: 'Database name'
    required: false
  db_user:
    description: 'Database user'
    required: false
  db_password:
    description: 'Database password'
    required: false
  db_root_password:
    description: 'Root password (MySQL only)'
    required: false
  db_host_port:
    description: 'Host port to expose DB (optional)'
    required: false
  db_data_volume:
    description: 'Podman volume name or host path for DB data'
    required: false
  db_image_tag:
    description: 'DB image tag (postgres default 16, mysql default 8)'
    required: false
  db_memory_limit:
    description: 'DB memory limit, e.g., 512m'
    required: false
    default: '512m'

  # Optional worker and scheduler services
  run_worker:
    description: 'Run a background worker container'
    required: false
    default: 'false'
  worker_service_name:
    description: 'Worker container name (default: worker-<app_slug>-<env_name>)'
    required: false
  worker_command:
    description: 'Worker command to run inside the app image (e.g., celery -A app worker -l info)'
    required: false
  worker_image:
    description: 'Alternate image for worker (defaults to API image)'
    required: false
  worker_memory_limit:
    description: 'Worker memory limit, e.g., 512m'
    required: false
    default: '512m'
  worker_volumes:
    description: 'Newline-separated list of volumes for the worker container'
    required: false

  run_scheduler:
    description: 'Run a scheduler/cron container'
    required: false
    default: 'false'
  scheduler_service_name:
    description: 'Scheduler container name (default: scheduler-<app_slug>-<env_name>)'
    required: false
  scheduler_command:
    description: 'Scheduler command to run inside the app image (e.g., celery -A app beat -l info)'
    required: false
  scheduler_image:
    description: 'Alternate image for scheduler (defaults to API image)'
    required: false
  scheduler_memory_limit:
    description: 'Scheduler memory limit, e.g., 512m'
    required: false
    default: '512m'
  scheduler_volumes:
    description: 'Newline-separated list of volumes for the scheduler container'
    required: false

runs:
  using: 'composite'
  steps:
    - name: Compute derived defaults
      id: dfl
      uses: ./.github/actions/app/common/compute-defaults
      with:
        env_name: ${{ inputs.env_name }}
        auto_detect_env: ${{ inputs.auto_detect_env }}
        domain: ${{ inputs.domain }}
        base_domain: ${{ inputs.base_domain }}
        domain_prefix_prod: ${{ inputs.domain_prefix_prod }}
        domain_prefix_staging: ${{ inputs.domain_prefix_staging }}
        domain_prefix_dev: ${{ inputs.domain_prefix_dev }}
    - name: Validate inputs
      env:
        J_IMAGE_NAME: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}
      run: |
        set -euo pipefail
        if [ -z "${{ inputs.ssh_host }}" ]; then echo 'Error: ssh_host is required' ; exit 1 ; fi
        if [ -z "${{ inputs.ssh_key }}" ]; then echo 'Error: ssh_key is required' ; exit 1 ; fi
        if [ -z "${J_IMAGE_NAME}" ]; then echo 'Error: image_name is required' ; exit 1 ; fi
        # registry creds only required for non-GHCR when registry_login=true
        if [ "${{ inputs.registry_login }}" = "true" ] && [ "${{ inputs.registry }}" != "ghcr.io" ]; then
          if [ -z "${{ inputs.registry_username }}" ] || [ -z "${{ inputs.registry_token }}" ]; then
            echo 'Error: registry_username and registry_token are required for non-GHCR registries when registry_login=true' ; exit 1
          fi
        fi
        # Env writing conditions
        if [ "${{ inputs.write_env_file }}" = "true" ]; then
          if [ -z "${{ inputs.env_b64 }}" ] && [ -z "${{ inputs.env_content }}" ]; then
            echo 'Error: write_env_file=true but neither env_b64 nor env_content provided' ; exit 1
          fi
        fi
      shell: bash

    - name: Prepare host (optional)
      if: ${{ inputs.prepare_host == 'true' }}
      uses: ./.github/actions/infra/prepare-ubuntu-host
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        install_podman: ${{ inputs.install_podman }}
        install_traefik: ${{ inputs.install_traefik }}
        traefik_email: ${{ inputs.traefik_email }}
        env_dir_path: ${{ inputs.env_dir_path != '' && inputs.env_dir_path || steps.dfl.outputs.env_dir_path }}
        additional_packages: ${{ inputs.additional_packages }}

    - name: Write env file (optional)
      if: ${{ inputs.write_env_file == 'true' }}
      uses: ./.github/actions/app/write-remote-env-file
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}
        env_b64: ${{ inputs.env_b64 }}
        env_content: ${{ inputs.env_content }}

    - name: Login and pull image
      uses: ./.github/actions/podman/podman-login-pull
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        registry: ${{ inputs.registry }}
        registry_username: ${{ inputs.registry_username }}
        registry_token: ${{ inputs.registry_token }}
        registry_login: ${{ inputs.registry_login }}
        image_name: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}
        image_tag: ${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }}

    - name: Deploy Django API
      uses: ./.github/actions/podman/remote-podman-exec
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}
        source_env: ${{ inputs.source_env }}
        fail_if_env_missing: ${{ inputs.fail_if_env_missing }}
        inline_script: |
          set -euo pipefail

          ENV_BASE="${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}"
          ENV_NAME="${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}"
          ENV_DIR="${ENV_BASE%/}/$ENV_NAME"
          ENV_FILE="${REMOTE_ENV_FILE:-${ENV_DIR}/.env}"
          IMAGE="${{ inputs.registry }}/${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}:${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }}"

          CN_IN="${{ inputs.container_name }}"
          APP_SLUG="${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}"
          CONTAINER_NAME="${CN_IN:-${APP_SLUG}-${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}}"

          HP_IN="${{ inputs.host_port }}"
          CP_IN="${{ inputs.container_port }}"
          if [ -n "$HP_IN" ]; then
            HOST_PORT="$HP_IN"
          else
            HOST_PORT="${API_HOST_PORT:-${PORT:-8000}}"
          fi
          if [ -n "$CP_IN" ]; then
            CONTAINER_PORT="$CP_IN"
          else
            CONTAINER_PORT="${API_CONTAINER_PORT:-${TARGET_PORT:-8000}}"
          fi

          run_podman stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
          run_podman rm "$CONTAINER_NAME" >/dev/null 2>&1 || true

          if [ "${{ inputs.migrate }}" = "true" ]; then
            # DNS handling for migration ephemeral run
            DNS_ARGS=""
            RSRC="/run/systemd/resolve/resolv.conf"
            if [ -r "$RSRC" ] && [ -s "$RSRC" ]; then
              [ "${DEBUG:-false}" = "true" ] && echo "ðŸ§­ DNS (migrate): mount $RSRC"
              DNS_ARGS="-v $RSRC:/etc/resolv.conf:ro"
            else
              [ "${DEBUG:-false}" = "true" ] && echo "ðŸ§­ DNS (migrate): public resolvers 1.1.1.1, 8.8.8.8"
              DNS_ARGS="--dns 1.1.1.1 --dns 8.8.8.8"
            fi

            run_podman run --rm --env-file "$ENV_FILE" \
              ${DNS_ARGS} \
              "$IMAGE" \
              ${{ inputs.migrate_cmd }}
          fi

          EXTRA_ARGS="${{ inputs.extra_run_args }}"
          TRAEFIK_ENABLED="${{ inputs.enable_traefik }}"
          DOMAIN_INPUT="${{ inputs.domain }}"
          DOMAIN_DEFAULT="${{ steps.dfl.outputs.domain_default }}"
          DOMAIN="$DOMAIN_INPUT"
          if [ -z "$DOMAIN" ]; then DOMAIN="$DOMAIN_DEFAULT"; fi
          ROUTER="${{ steps.dfl.outputs.traefik_router }}"

          declare -a PORT_ARGS=()
          declare -a LABEL_ARGS=()

          if [ "$TRAEFIK_ENABLED" = "true" ] && [ -n "$DOMAIN" ]; then
            LABEL_ARGS+=(--label "traefik.enable=true")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.rule=Host(\`$DOMAIN\`)")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.entrypoints=websecure")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.tls.certresolver=letsencrypt")
            LABEL_ARGS+=(--label "traefik.http.services.${ROUTER}.loadbalancer.server.port=$CONTAINER_PORT")
          else
            PORT_ARGS=(-p "$HOST_PORT:$CONTAINER_PORT")
          fi

          # DNS handling for main app container
          DNS_ARGS=""
          RSRC="/run/systemd/resolve/resolv.conf"
          if [ -r "$RSRC" ] && [ -s "$RSRC" ]; then
            [ "${DEBUG:-false}" = "true" ] && echo "ðŸ§­ DNS: mount $RSRC"
            DNS_ARGS="-v $RSRC:/etc/resolv.conf:ro"
          else
            [ "${DEBUG:-false}" = "true" ] && echo "ðŸ§­ DNS: public resolvers 1.1.1.1, 8.8.8.8"
            DNS_ARGS="--dns 1.1.1.1 --dns 8.8.8.8"
          fi

          run_podman run -d --name "$CONTAINER_NAME" --env-file "$ENV_FILE" \
            "${PORT_ARGS[@]}" \
            ${DNS_ARGS} \
            --restart=${{ inputs.restart_policy }} \
            --memory='${{ inputs.memory_limit }}' --memory-swap='${{ inputs.memory_limit }}' \
            ${EXTRA_ARGS:+$EXTRA_ARGS} \
            "${LABEL_ARGS[@]}" \
            "$IMAGE"

    - name: Run worker (optional)
      if: ${{ inputs.run_worker == 'true' }}
      uses: ./.github/actions/podman/podman-run-service
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        service_name: ${{ inputs.worker_service_name }}
        image: ${{ inputs.worker_image != '' && inputs.worker_image || format('{0}/{1}:{2}', inputs.registry, (inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name), inputs.image_tag) }}
        env_file: ${{ (inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path) }}${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}/.env
        command: ${{ inputs.worker_command }}
        restart_policy: unless-stopped
        memory_limit: ${{ inputs.worker_memory_limit }}
        volumes: ${{ inputs.worker_volumes }}

    - name: Run scheduler (optional)
      if: ${{ inputs.run_scheduler == 'true' }}
      uses: ./.github/actions/podman/podman-run-service
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        service_name: ${{ inputs.scheduler_service_name }}
        image: ${{ inputs.scheduler_image != '' && inputs.scheduler_image || format('{0}/{1}:{2}', inputs.registry, (inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name), (inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default)) }}
        env_file: ${{ (inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path) }}${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        command: ${{ inputs.scheduler_command }}
        restart_policy: unless-stopped
        memory_limit: ${{ inputs.scheduler_memory_limit }}
        volumes: ${{ inputs.scheduler_volumes }}
