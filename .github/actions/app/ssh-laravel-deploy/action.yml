# ============================================================================
# ACTION: SSH Laravel Deploy
# ============================================================================
# PURPOSE:
# Deploys a Laravel application to a remote server via SSH using Podman.
# Similar to Django deploy but tailored for Laravel applications.
#
# WHAT IT DOES:
# 1. Optionally prepares a fresh Ubuntu host (Podman, Traefik, directories)
# 2. Writes environment file to remote server
# 3. Logs in to container registry and pulls image
# 4. Runs Laravel migrations (optional)
# 5. Starts Laravel container with Traefik routing
# 6. Optionally starts database, worker, and scheduler containers
#
# WHEN TO USE:
# - Deploy Laravel applications
# - Deploy to production, staging, or development environments
# - First deployment to a new server (set prepare_host: true)
# - Subsequent deployments (prepare_host: false)
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for complete guide
# ============================================================================

name: 'SSH Laravel Deploy'
description: 'Upload env (optional) and deploy a Laravel container via Podman over SSH with Traefik routing and optional migrations.'

# ============================================================================
# INPUTS - Organized by category (similar to ssh-django-deploy)
# ============================================================================
inputs:
  ssh_host:
    description: 'SSH host'
    required: true
  ssh_user:
    description: 'SSH username'
    required: true
  ssh_key:
    description: 'SSH private key'
    required: true
  ssh_port:
    description: 'SSH port'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Server SSH host key fingerprint (optional)'
    required: false

  prepare_host:
    description: 'Install Podman and prepare directories/users on a fresh Ubuntu host'
    required: false
    default: 'false'
  install_podman:
    description: 'Install Podman when preparing host'
    required: false
    default: 'true'
  install_traefik:
    description: 'Install Traefik when prepare_host runs'
    required: false
    default: 'true'
  traefik_email:
    description: "Email used for Traefik Let's Encrypt resolver (required if install_traefik=true)"
    required: false
  enable_traefik:
    description: 'Attach Traefik routing labels when a domain is available'
    required: false
    default: 'true'
  env_dir_path:
    description: 'Directory to hold env files and app data on the server'
    required: false
  additional_packages:
    description: 'Space-separated additional apt packages for host preparation'
    required: false
    default: 'jq curl ca-certificates'

  env_name:
    description: 'Environment name used to build container and env file path'
    required: false
  auto_detect_env:
    description: 'Auto-detect environment name from branch when true'
    required: false
    default: 'true'
  env_file_path:
    description: 'Base directory on the server; the final file is <env_file_path>/<env_name>/.env'
    required: false
  write_env_file:
    description: 'If true, write the env file on the server before deploy'
    required: false
    default: 'false'
  env_b64:
    description: 'Base64-encoded contents of the .env file to write on the server'
    required: false
  env_content:
    description: 'Raw contents of the .env file to write on the server (use env_b64 instead when possible)'
    required: false

  registry:
    description: 'Container registry hostname'
    required: false
    default: 'ghcr.io'
  image_name:
    description: 'Image name (e.g., org/app)'
    required: false
  image_tag:
    description: 'Image tag to deploy'
    required: false
  registry_username:
    description: 'Registry username (for ghcr.io use your GH username)'
    required: false
  registry_token:
    description: 'Registry token/password (for ghcr.io can be a PAT or GitHub token with package:write)'
    required: false
  registry_login:
    description: 'Log in to registry before pulling image'
    required: false
    default: 'true'

  app_slug:
    description: 'Slug used in default container name'
    required: false
  container_name:
    description: 'Override container name (defaults to ${app_slug}-${env_name})'
    required: false
  host_port:
    description: 'Override host port (default derived from env file: APP_HOST_PORT or PORT, else 8000)'
    required: false
  container_port:
    description: 'Override container port (default derived from env file: APP_CONTAINER_PORT or TARGET_PORT, else 8000)'
    required: false
  restart_policy:
    description: 'Container restart policy'
    required: false
    default: 'unless-stopped'
  migrate:
    description: 'Run Laravel migrations before starting the container'
    required: false
    default: 'true'
  migrate_cmd:
    description: 'Command to run migrations'
    required: false
    default: 'php artisan migrate --force'
  extra_run_args:
    description: 'Additional args passed to podman run'
    required: false
  memory_limit:
    description: 'Container memory limit, e.g., 512m'
    required: false
    default: '512m'

  source_env:
    description: 'Source ENV_FILE prior to deploy commands'
    required: false
    default: 'true'
  fail_if_env_missing:
    description: 'Fail if source_env is true and env file is missing'
    required: false
    default: 'true'

  manage_vhost:
    description: '[Deprecated] Apache vhost management is disabled in favor of Traefik'
    required: false
    default: 'false'
  domain:
    description: 'Full domain to configure (optional)'
    required: false
  base_domain:
    description: 'Base domain used to compute domain if domain is not provided'
    required: false
  domain_prefix_prod:
    description: 'Domain prefix for production/main env'
    required: false
    default: 'app'
  domain_prefix_staging:
    description: 'Domain prefix for staging env'
    required: false
  domain_prefix_dev:
    description: 'Domain prefix for dev env'
    required: false
  vhost_mode:
    description: "VHost mode: 'reverse_proxy' (default)"
    required: false
    default: 'reverse_proxy'
  require_dns_match:
    description: 'Require domain A-record match to server public IP before applying changes'
    required: false
    default: 'true'

runs:
  using: 'composite'
  steps:
    - name: Compute derived defaults
      id: dfl
      uses: ./.github/actions/app/common/compute-defaults
      with:
        env_name: ${{ inputs.env_name }}
        auto_detect_env: ${{ inputs.auto_detect_env }}
        domain: ${{ inputs.domain }}
        base_domain: ${{ inputs.base_domain }}
        domain_prefix_prod: ${{ inputs.domain_prefix_prod }}
        domain_prefix_staging: ${{ inputs.domain_prefix_staging }}
        domain_prefix_dev: ${{ inputs.domain_prefix_dev }}

    - name: Validate inputs
      run: |
        set -euo pipefail
        if [ -z "${{ inputs.ssh_host }}" ]; then echo 'Error: ssh_host is required' ; exit 1 ; fi
        if [ -z "${{ inputs.ssh_key }}" ]; then echo 'Error: ssh_key is required' ; exit 1 ; fi
        if [ "${{ inputs.registry_login }}" = "true" ] && [ "${{ inputs.registry }}" != "ghcr.io" ]; then
          if [ -z "${{ inputs.registry_username }}" ] || [ -z "${{ inputs.registry_token }}" ]; then
            echo 'Error: registry_username and registry_token are required for non-GHCR registries when registry_login=true' ; exit 1
          fi
        fi
        if [ "${{ inputs.write_env_file }}" = "true" ]; then
          if [ -z "${{ inputs.env_b64 }}" ] && [ -z "${{ inputs.env_content }}" ]; then
            echo 'Error: write_env_file=true but neither env_b64 nor env_content provided' ; exit 1
          fi
        fi
      shell: bash

    - name: Prepare host (optional)
      if: ${{ inputs.prepare_host == 'true' }}
      uses: ./.github/actions/infra/prepare-ubuntu-host
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        install_podman: ${{ inputs.install_podman }}
        install_traefik: ${{ inputs.install_traefik }}
        traefik_email: ${{ inputs.traefik_email }}
        env_dir_path: ${{ inputs.env_dir_path != '' && inputs.env_dir_path || steps.dfl.outputs.env_dir_path }}
        additional_packages: ${{ inputs.additional_packages }}

    - name: Write env file (optional)
      if: ${{ inputs.write_env_file == 'true' }}
      uses: ./.github/actions/app/write-remote-env-file
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}
        env_b64: ${{ inputs.env_b64 }}
        env_content: ${{ inputs.env_content }}

    - name: Login and pull image
      uses: ./.github/actions/podman/podman-login-pull
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        registry: ${{ inputs.registry }}
        registry_username: ${{ inputs.registry_username }}
        registry_token: ${{ inputs.registry_token }}
        registry_login: ${{ inputs.registry_login }}
        image_name: ${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}
        image_tag: ${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }}

    - name: Deploy Laravel app
      uses: ./.github/actions/podman/remote-podman-exec
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        env_name: ${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}
        source_env: ${{ inputs.source_env }}
        fail_if_env_missing: ${{ inputs.fail_if_env_missing }}
        inline_script: |
          set -euo pipefail

          ENV_BASE="${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}"
          ENV_NAME="${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}"
          ENV_DIR="${ENV_BASE%/}/$ENV_NAME"
          ENV_FILE="${REMOTE_ENV_FILE:-${ENV_DIR}/.env}"
          IMAGE="${{ inputs.registry }}/${{ inputs.image_name != '' && inputs.image_name || steps.dfl.outputs.image_name }}:${{ inputs.image_tag != '' && inputs.image_tag || steps.dfl.outputs.image_tag_default }}"

          CN_IN="${{ inputs.container_name }}"
          APP_SLUG="${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}"
          CONTAINER_NAME="${CN_IN:-${APP_SLUG}-${{ inputs.env_name != '' && inputs.env_name || steps.dfl.outputs.env_name_default }}}"

          HP_IN="${{ inputs.host_port }}"
          CP_IN="${{ inputs.container_port }}"
          if [ -n "$HP_IN" ]; then
            HOST_PORT="$HP_IN"
          else
            HOST_PORT="${APP_HOST_PORT:-${PORT:-8000}}"
          fi
          if [ -n "$CP_IN" ]; then
            CONTAINER_PORT="$CP_IN"
          else
            CONTAINER_PORT="${APP_CONTAINER_PORT:-${TARGET_PORT:-8000}}"
          fi

          if [ "${{ inputs.migrate }}" = "true" ]; then
            # DNS handling for migration ephemeral run
            DNS_ARGS=()
            RSRC="/run/systemd/resolve/resolv.conf"
            if [ -r "$RSRC" ] && [ -s "$RSRC" ]; then
              [ "${DEBUG:-false}" = "true" ] && echo "ðŸ§­ DNS (migrate): mount $RSRC"
              DNS_ARGS+=( -v "$RSRC:/etc/resolv.conf:ro" )
            else
              [ "${DEBUG:-false}" = "true" ] && echo "ðŸ§­ DNS (migrate): public resolvers 1.1.1.1, 8.8.8.8"
              DNS_ARGS+=( --dns 1.1.1.1 --dns 8.8.8.8 )
            fi

            podman run --rm --env-file "$ENV_FILE" \
              "${DNS_ARGS[@]}" \
              "$IMAGE" \
              ${{ inputs.migrate_cmd }}
          fi

          podman stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
          podman rm "$CONTAINER_NAME" >/dev/null 2>&1 || true

          EXTRA_ARGS="${{ inputs.extra_run_args }}"
          TRAEFIK_ENABLED="${{ inputs.enable_traefik }}"
          DOMAIN_INPUT="${{ inputs.domain }}"
          DOMAIN_DEFAULT="${{ steps.dfl.outputs.domain_default }}"
          DOMAIN="$DOMAIN_INPUT"
          if [ -z "$DOMAIN" ]; then DOMAIN="$DOMAIN_DEFAULT"; fi
          ROUTER="${{ steps.dfl.outputs.traefik_router }}"

          declare -a PORT_ARGS=()
          declare -a LABEL_ARGS=()

          if [ "$TRAEFIK_ENABLED" = "true" ] && [ -n "$DOMAIN" ]; then
            LABEL_ARGS+=(--label "traefik.enable=true")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.rule=Host(\`$DOMAIN\`)")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.entrypoints=websecure")
            LABEL_ARGS+=(--label "traefik.http.routers.${ROUTER}.tls.certresolver=letsencrypt")
            LABEL_ARGS+=(--label "traefik.http.services.${ROUTER}.loadbalancer.server.port=$CONTAINER_PORT")
          else
            PORT_ARGS=(-p "$HOST_PORT:$CONTAINER_PORT")
          fi

          # DNS handling for main app container
          DNS_ARGS=()
          RSRC="/run/systemd/resolve/resolv.conf"
          if [ -r "$RSRC" ] && [ -s "$RSRC" ]; then
            [ "${DEBUG:-false}" = "true" ] && echo "ðŸ§­ DNS: mount $RSRC"
            DNS_ARGS+=( -v "$RSRC:/etc/resolv.conf:ro" )
          else
            [ "${DEBUG:-false}" = "true" ] && echo "ðŸ§­ DNS: public resolvers 1.1.1.1, 8.8.8.8"
            DNS_ARGS+=( --dns 1.1.1.1 --dns 8.8.8.8 )
          fi

          podman run -d --name "$CONTAINER_NAME" --env-file "$ENV_FILE" \
            "${PORT_ARGS[@]}" \
            "${DNS_ARGS[@]}" \
            --restart=${{ inputs.restart_policy }} \
            --memory='${{ inputs.memory_limit }}' --memory-swap='${{ inputs.memory_limit }}' \
            ${EXTRA_ARGS:+$EXTRA_ARGS} \
            "${LABEL_ARGS[@]}" \
            "$IMAGE"
