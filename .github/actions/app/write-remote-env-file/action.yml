# ============================================================================
# ACTION: Write Remote Env File
# ============================================================================
# PURPOSE:
# Securely writes a .env file to a remote server via SSH.
# Handles base64-encoded or raw environment file contents.
#
# WHAT IT DOES:
# 1. Validates inputs (env_name, env_b64 or env_content)
# 2. Computes derived defaults (paths, app_slug)
# 3. Creates directory structure on remote server
# 4. Decodes base64 or writes raw content
# 5. Sets correct permissions (600) and ownership
#
# WHEN TO USE:
# - Upload environment files to remote server
# - Part of deployment pipeline (called by deployment actions)
# - Manage multiple environment files (dev, staging, prod)
# - Update .env files without redeploying
#
# SECURITY:
# - Supports base64-encoded content (preferred)
# - Sets file permissions to 600 (read/write owner only)
# - Supports SSH host key verification
# - Handles sensitive data securely
#
# REFERENCE: See docs/GETTING_STARTED.md Step 2 and docs/ACTION_FILES_GUIDE.md
# ============================================================================

name: 'Write Remote Env File'
description: 'Securely writes a .env file to the remote host via SSH.'

# ============================================================================
# INPUTS - Organized by category
# ============================================================================
inputs:
  # ========================================================================
  # SSH / REMOTE EXECUTION
  # ========================================================================
  ssh_host:
    description: 'SSH host (IP or hostname). Required. Example: 192.168.1.100'
    required: true
  ssh_user:
    description: 'SSH username (non-root). Required. Used for authentication'
    required: true
  ssh_key:
    description: 'SSH private key for authentication. Required. Should be stored as GitHub secret'
    required: true
  root_ssh_key:
    description: 'SSH private key for root (optional). Use if ssh_user cannot escalate to root'
    required: false
  ssh_port:
    description: 'SSH port. Default: 22. Change if using non-standard SSH port'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Server SSH host key fingerprint for verification. Optional but recommended for security'
    required: false
  connect_mode:
    description: "Connection mode: 'auto' (default), 'root', or 'user'. See docs/ARCHITECTURE.md"
    required: false
    default: 'auto'
  skip_upload:
    description: 'Skip staging/upload (assumes scripts bundle already deployed via deploy-server-scripts)'
    required: false
    default: 'true'

  # ========================================================================
  # ENVIRONMENT FILE CONFIGURATION
  # ========================================================================
  env_name:
    description: 'Environment name (production, staging, development). Required. Used in file path'
    required: true
  env_file_path:
    description: 'Base directory for env files. Default: ~/deployments (user-writable, no sudo required). Final path: <env_file_path>/<env_name>/<app_slug>/.env'
    required: false
    default: '~/deployments'
  app_slug:
    description: 'Application slug for directory structure. Auto-derived from repo if not provided. Example: myapp'
    required: false

  # ========================================================================
  # ENVIRONMENT FILE CONTENT
  # ========================================================================
  env_b64:
    description: 'Base64-encoded .env file contents. Preferred for security. Create with: cat .env | base64'
    required: false
  env_content:
    description: 'Raw .env file contents. Use env_b64 instead when possible for security'
    required: false

# ============================================================================
# EXECUTION STEPS
# ============================================================================
# The file writing follows these steps:
# 1. Compute defaults - Calculate derived values
# 2. Validate inputs - Check required parameters
# 3. Write env file - Create directory and write file
# 4. Set permissions - chmod 600 (directories must be writable by SSH user)
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for detailed step explanations
# ============================================================================

runs:
  using: 'composite'
  steps:
    # Probe: Check SSH reachability to avoid scp timeouts
    - name: Check SSH reachability
      id: reach
      shell: bash
      env:
        SSH_HOST: ${{ inputs.ssh_host }}
        SSH_USER: ${{ inputs.ssh_user }}
        SSH_KEY: ${{ inputs.ssh_key }}
        SSH_PORT: ${{ inputs.ssh_port }}
      run: |
        set -euo pipefail
        KEY_FILE="$(mktemp)"
        trap "rm -f '$KEY_FILE'" EXIT
        if printf '%s' "$SSH_KEY" | grep -q '\\n'; then
          printf '%s\n' "$SSH_KEY" | sed 's/\\n/\n/g' > "$KEY_FILE"
        else
          printf '%s\n' "$SSH_KEY" > "$KEY_FILE"
        fi
        chmod 600 "$KEY_FILE"
        if ssh -i "$KEY_FILE" -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=8 -p "${SSH_PORT:-22}" "$SSH_USER@$SSH_HOST" true 2>/dev/null; then
          echo "reachable=true" >> "$GITHUB_OUTPUT"
        else
          echo "reachable=false" >> "$GITHUB_OUTPUT"
        fi
    # ========================================================================
    # STEP 1: Compute derived defaults
    # ========================================================================
    # Calculates values like env_file_path and app_slug if not provided
    # ========================================================================
    - name: Compute derived defaults
      id: dfl
      uses: ./.github/actions/app/common/compute-defaults
    
    # ========================================================================
    # STEP 2: Validate inputs
    # ========================================================================
    # Checks that required parameters are provided
    # Ensures either env_b64 or env_content is provided
    # ========================================================================
    - name: Validate inputs
      run: |
        set -euo pipefail
        if [ -z "${{ inputs.ssh_host }}" ]; then echo 'Error: ssh_host is required' ; exit 1 ; fi
        if [ -z "${{ inputs.ssh_user }}" ]; then echo 'Error: ssh_user is required' ; exit 1 ; fi
        if [ -z "${{ inputs.ssh_key }}" ]; then echo 'Error: ssh_key is required' ; exit 1 ; fi
        if [ -z "${{ inputs.env_name }}" ]; then echo 'Error: env_name is required' ; exit 1 ; fi
        if [ -z "${{ inputs.env_b64 }}" ] && [ -z "${{ inputs.env_content }}" ]; then
          echo 'Error: Either env_b64 or env_content must be provided' ; exit 1
        fi
      shell: bash

    # Stage: Copy script from action path to workspace
    - name: Stage run-env-setup script for upload
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.skip_upload != 'true' }}
      shell: bash
      env:
        ACTION_PATH: ${{ github.action_path }}
        WORKSPACE: ${{ github.workspace }}
      run: |
        set -euo pipefail
        mkdir -p "$WORKSPACE/.uactions_cache"
        SRC_REL="../../../scripts/app/run-env-setup.sh"
        cp "$ACTION_PATH/$SRC_REL" "$WORKSPACE/.uactions_cache/run-env-setup.sh"

    - name: Upload env setup script
      if: ${{ steps.reach.outputs.reachable == 'true' && inputs.skip_upload != 'true' }}
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ inputs.ssh_user }}
        key: ${{ inputs.ssh_key }}
        port: ${{ inputs.ssh_port }}
        source: ".uactions_cache/run-env-setup.sh"
        target: "/tmp"
        overwrite: true
        strip_components: 1
        timeout: 15s
        command_timeout: 30s

    - name: Write remote environment file
      if: ${{ steps.reach.outputs.reachable == 'true' }}
      uses: ./.github/actions/podman/remote-podman-exec
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        env_name: ${{ inputs.env_name }}
        env_file_path: ${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}
        app_slug: ${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}
        source_env: 'false'
        fail_if_env_missing: 'false'
        inline_script: |
          set -euo pipefail
          # Move scripts to place
          mkdir -p "$HOME/uactions/scripts/app"
          if [ -f /tmp/run-env-setup.sh ]; then
            mv -f /tmp/run-env-setup.sh "$HOME/uactions/scripts/app/run-env-setup.sh"
            chmod +x "$HOME/uactions/scripts/app/run-env-setup.sh"
          fi

          # Export variables for run-env-setup.sh
          export ENV_FILE_PATH='${{ inputs.env_file_path != '' && inputs.env_file_path || steps.dfl.outputs.env_file_path }}/${{ inputs.env_name }}/${{ inputs.app_slug != '' && inputs.app_slug || steps.dfl.outputs.app_slug }}/.env'
          export ENV_B64='${{ inputs.env_b64 }}'
          export ENV_CONTENT='${{ inputs.env_content }}'

          # Execute environment setup runner script
          "$HOME/uactions/scripts/app/run-env-setup.sh"
