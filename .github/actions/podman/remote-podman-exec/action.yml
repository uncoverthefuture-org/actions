name: 'Remote Podman Exec'
description: 'Run remote commands over SSH with a run_podman helper, supporting root or user.'

inputs:
  ssh_host:
    description: 'SSH host'
    required: true
  ssh_user:
    description: 'SSH username (non-root)'
    required: true
  ssh_key:
    description: 'SSH private key for non-root user'
    required: true
  root_ssh_key:
    description: 'SSH private key for root (optional)'
    required: false
  ssh_port:
    description: 'SSH port'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Server SSH host key fingerprint to verify host identity (optional but recommended)'
    required: false
  podman_user:
    description: 'User on remote host to execute podman commands as'
    required: false
    default: 'deployer'
  connect_mode:
    description: "How to connect: 'auto' (default), 'root', or 'user'"
    required: false
    default: 'auto'
  env_file_path:
    description: 'Base directory for env files on the server; the action creates <env_file_path>/<env_name>/<app_slug>/.env'
    required: false
    default: ''
  env_name:
    description: 'Environment name (used as subdirectory under env_file_path)'
    required: false
  source_env:
    description: 'Source ENV_FILE before running inline script'
    required: false
    default: 'false'
  fail_if_env_missing:
    description: 'Fail if source_env is true and env file is missing'
    required: false
    default: 'false'
  inline_script:
    description: 'Inline script to run on the remote host; run_podman helper is available'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      run: |
        if [ -z "${{ inputs.ssh_host }}" ]; then echo '::error::ssh_host is required'; exit 1 ; fi
        if [ -z "${{ inputs.ssh_user }}" ]; then echo '::error::ssh_user is required'; exit 1 ; fi
        if [ -z "${{ inputs.ssh_key }}" ]; then echo '::error::ssh_key is required'; exit 1 ; fi
        if [ -z "${{ inputs.inline_script }}" ]; then echo '::error::inline_script is required'; exit 1 ; fi
        case "${{ inputs.connect_mode }}" in
          auto|root|user) :;;
          *) echo '::error::connect_mode must be auto|root|user'; exit 1 ;;
        esac
      shell: bash

    - name: Resolve connection
      id: conn
      shell: bash
      run: |
        set -euo pipefail

        PODMAN_USER="${{ inputs.podman_user }}"
        CONNECT_MODE="${{ inputs.connect_mode }}"
        SSH_USER="${{ inputs.ssh_user }}"
        SSH_KEY="${{ inputs.ssh_key }}"
        ROOT_KEY="${{ inputs.root_ssh_key }}"

        USERNAME=""
        KEY_VALUE=""

        if [ "$CONNECT_MODE" = "root" ] || { [ "$CONNECT_MODE" = "auto" ] && [ "$PODMAN_USER" = "root" ]; }; then
          USERNAME="root"
          if [ -n "$ROOT_KEY" ]; then
            KEY_VALUE="$ROOT_KEY"
          else
            KEY_VALUE="$SSH_KEY"
          fi
        else
          USERNAME="$SSH_USER"
          KEY_VALUE="$SSH_KEY"
        fi

        if [ -z "$USERNAME" ]; then
          echo '::error::Unable to resolve SSH username' >&2
          exit 1
        fi

        printf 'username=%s\n' "$USERNAME" >> "$GITHUB_OUTPUT"
        printf 'key<<EOF\n%s\nEOF\n' "$KEY_VALUE" >> "$GITHUB_OUTPUT"

    - name: Execute remote podman script
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ steps.conn.outputs.username }}
        key: ${{ steps.conn.outputs.key }}
        port: ${{ inputs.ssh_port }}
        fingerprint: ${{ inputs.ssh_fingerprint }}
        script: |
          set -euo pipefail

          PODMAN_USER="${{ inputs.podman_user }}"

          ENV_ROOT="${{ inputs.env_file_path }}"
          ENV_NAME_INPUT="${{ inputs.env_name }}"
          ENV_DIR=""
          ENV_FILE=""

          if [ -z "$ENV_ROOT" ]; then
            ENV_ROOT="/var/deployments"
          fi

          ENV_ROOT="${ENV_ROOT%/}"

          if [ -z "$ENV_NAME_INPUT" ]; then
            REF_NAME="${GITHUB_REF_NAME:-}"
            case "$REF_NAME" in
              main|master|production) ENV_NAME_INPUT='production' ;;
              stage|staging) ENV_NAME_INPUT='staging' ;;
              dev|develop|development) ENV_NAME_INPUT='development' ;;
              refs/tags/*) ENV_NAME_INPUT='production' ;;
              *) ENV_NAME_INPUT='development' ;;
            esac
          elif [ "$ENV_NAME_INPUT" = "dev" ]; then
            ENV_NAME_INPUT='development'
          fi

          APP_SLUG_INPUT="${{ inputs.app_slug }}"
          if [ -z "$APP_SLUG_INPUT" ]; then
            REPO_NAME_RAW="${GITHUB_REPOSITORY:-}"
            if [ -n "$REPO_NAME_RAW" ]; then
              REPO_NAME="${REPO_NAME_RAW##*/}"
            else
              REPO_NAME='app'
            fi
            APP_SLUG_INPUT=$(printf '%s' "$REPO_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
          fi

          ENV_DIR="${ENV_ROOT}/${ENV_NAME_INPUT}/${APP_SLUG_INPUT}"

          if ! mkdir -p "$ENV_DIR"; then
            echo "::error::Unable to create env directory $ENV_DIR" >&2
            exit 1
          fi

          ENV_FILE="${ENV_DIR}/.env"
          if [ ! -f "$ENV_FILE" ]; then
            {
              printf '# Generated by uactions package (remote-podman-exec).\n'
              printf '# Populate with KEY=VALUE pairs required for your deployment.\n'
            } > "$ENV_FILE"
            chown "$PODMAN_USER":"$PODMAN_USER" "$ENV_FILE" >/dev/null 2>&1 || true
            chmod 600 "$ENV_FILE" >/dev/null 2>&1 || true
          fi

          if [ "${{ inputs.source_env }}" = "true" ]; then
            if [ -z "$ENV_FILE" ]; then
              echo '::error::env_file_path must be provided when source_env=true'
              exit 1
            fi

            if [ -f "$ENV_FILE" ]; then
              set -a
              . "$ENV_FILE"
              set +a
            else
              if [ "${{ inputs.fail_if_env_missing }}" = "true" ]; then
                echo "::error::Environment file ${ENV_FILE} not found"
                echo "Environment file ${ENV_FILE} not found" >&2
                exit 1
              else
                echo "::warning::Environment file ${ENV_FILE} not found; continuing without sourcing"
              fi
            fi
          fi

          export REMOTE_ENV_FILE="$ENV_FILE"
          export REMOTE_ENV_DIR="$ENV_DIR"

          run_podman() {
            if [ "$(id -un)" = "$PODMAN_USER" ]; then
              podman "$@"
            else
              sudo -H -u "$PODMAN_USER" podman "$@"
            fi
          }

          if ! command -v podman >/dev/null 2>&1; then
            echo '::error::podman is not installed on the remote host'
            echo 'Error: podman is not installed on the remote host.' >&2
            echo 'Hint: enable host preparation in the calling action (prepare_host: true) or install podman manually.' >&2
            exit 1
          fi

          cd /

          # Begin inline script
          ${{ inputs.inline_script }}
