# ============================================================================
# ACTION: Remote Podman Exec
# ============================================================================
# PURPOSE:
# Executes arbitrary commands on a remote server via SSH with Podman support.
# Provides a run_podman helper function for container operations.
#
# WHAT IT DOES:
# 1. Connects to remote server via SSH
# 2. Optionally sources environment file (.env)
# 3. Provides run_podman helper function
# 4. Executes inline script on remote host
# 5. Returns output to GitHub Actions
#
# WHEN TO USE:
# - Run custom deployment scripts on remote server
# - Execute Podman commands (start, stop, exec, etc.)
# - Run database migrations
# - Execute any remote commands via SSH
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for complete guide
# ============================================================================

name: 'Remote Podman Exec'
description: 'Run remote commands over SSH with a run_podman helper, supporting root or user.'

# ============================================================================
# INPUTS - Organized by category
# ============================================================================
inputs:
  ssh_host:
    description: 'SSH host'
    required: true
  ssh_user:
    description: 'SSH username (non-root)'
    required: true
  ssh_key:
    description: 'SSH private key for non-root user'
    required: true
  root_ssh_key:
    description: 'SSH private key for root (optional)'
    required: false
  ssh_port:
    description: 'SSH port'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Server SSH host key fingerprint to verify host identity (optional but recommended)'
    required: false
  podman_user:
    description: 'User on remote host to execute podman commands as'
    required: false
    default: 'deployer'
  app_slug:
    description: 'Application slug used to derive default paths and names'
    required: false
    default: ''
  connect_mode:
    description: "How to connect: 'auto' (default), 'root', or 'user'"
    required: false
    default: 'auto'
  skip_if_unreachable:
    description: 'Skip remote execution when SSH host is unreachable (prevents noisy timeouts)'
    required: false
    default: 'true'
  env_file_path:
    description: 'Base directory for env files on the server; the action creates <env_file_path>/<env_name>/<app_slug>/.env'
    required: false
    default: ''
  env_name:
    description: 'Environment name (used as subdirectory under env_file_path)'
    required: false
  source_env:
    description: 'Source ENV_FILE before running inline script'
    required: false
    default: 'false'
  fail_if_env_missing:
    description: 'Fail if source_env is true and env file is missing'
    required: false
    default: 'false'
  inline_script:
    description: 'Inline script to run on the remote host; run_podman helper is available'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      env:
        SSH_HOST: ${{ inputs.ssh_host }}
        SSH_USER: ${{ inputs.ssh_user }}
        SSH_KEY: ${{ inputs.ssh_key }}
        INLINE_SCRIPT: ${{ inputs.inline_script }}
        CONNECT_MODE: ${{ inputs.connect_mode }}
      run: |
        set -euo pipefail
        if [ -z "${SSH_HOST}" ]; then echo '::error::ssh_host is required'; exit 1 ; fi
        if [ -z "${SSH_USER}" ]; then echo '::error::ssh_user is required'; exit 1 ; fi
        if [ -z "${SSH_KEY}" ]; then echo '::error::ssh_key is required'; exit 1 ; fi
        if [ -z "${INLINE_SCRIPT}" ]; then echo '::error::inline_script is required'; exit 1 ; fi
        case "${CONNECT_MODE}" in
          auto|root|user) :;;
          *) echo '::error::connect_mode must be auto|root|user'; exit 1 ;;
        esac

    - name: Resolve connection
      id: conn
      shell: bash
      run: |
        set -euo pipefail

        PODMAN_USER="${{ inputs.podman_user }}"
        CONNECT_MODE="${{ inputs.connect_mode }}"
        SSH_USER="${{ inputs.ssh_user }}"
        SSH_KEY="${{ inputs.ssh_key }}"
        ROOT_KEY="${{ inputs.root_ssh_key }}"

        USERNAME=""
        KEY_VALUE=""

        if [ "$CONNECT_MODE" = "root" ] || { [ "$CONNECT_MODE" = "auto" ] && [ "$PODMAN_USER" = "root" ]; }; then
          USERNAME="root"
          if [ -n "$ROOT_KEY" ]; then
            KEY_VALUE="$ROOT_KEY"
          else
            KEY_VALUE="$SSH_KEY"
          fi
        else
          USERNAME="$SSH_USER"
          KEY_VALUE="$SSH_KEY"
        fi

        if [ -z "$USERNAME" ]; then
          echo '::error::Unable to resolve SSH username' >&2
          exit 1
        fi

        printf 'username=%s\n' "$USERNAME" >> "$GITHUB_OUTPUT"
        printf 'key<<EOF\n%s\nEOF\n' "$KEY_VALUE" >> "$GITHUB_OUTPUT"

    - name: Probe SSH reachability
      id: probe
      shell: bash
      env:
        SSH_HOST: ${{ inputs.ssh_host }}
        SSH_PORT: ${{ inputs.ssh_port }}
        SSH_USER_EFF: ${{ steps.conn.outputs.username }}
        SSH_KEY_EFF: ${{ steps.conn.outputs.key }}
      run: |
        set -euo pipefail
        KEY_FILE="$(mktemp)"
        trap "rm -f '$KEY_FILE'" EXIT
        printf '%s\n' "$SSH_KEY_EFF" > "$KEY_FILE"
        chmod 600 "$KEY_FILE"
        if ssh -i "$KEY_FILE" -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=8 -p "${SSH_PORT:-22}" "$SSH_USER_EFF@$SSH_HOST" true 2>/dev/null; then
          echo "reachable=true" >> "$GITHUB_OUTPUT"
        else
          echo "reachable=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Execute remote podman script
      if: ${{ steps.probe.outputs.reachable == 'true' || inputs.skip_if_unreachable == 'false' }}
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ steps.conn.outputs.username }}
        key: ${{ steps.conn.outputs.key }}
        port: ${{ inputs.ssh_port }}
        fingerprint: ${{ inputs.ssh_fingerprint }}
        script: |
          set -eu

          bash -s <<'BASH_EOF'
          set -euo pipefail

          PODMAN_USER="${{ inputs.podman_user }}"

          ENV_ROOT="${{ inputs.env_file_path }}"
          ENV_NAME_INPUT="${{ inputs.env_name }}"
          ENV_DIR=""
          ENV_FILE=""

          if [ -z "$ENV_ROOT" ]; then
            ENV_ROOT="/var/deployments"
          fi

          ENV_ROOT="${ENV_ROOT%/}"

          if [ -z "$ENV_NAME_INPUT" ]; then
            REF_NAME="${GITHUB_REF_NAME:-}"
            case "$REF_NAME" in
              main|master|production) ENV_NAME_INPUT='production' ;;
              stage|staging) ENV_NAME_INPUT='staging' ;;
              dev|develop|development) ENV_NAME_INPUT='development' ;;
              refs/tags/*) ENV_NAME_INPUT='production' ;;
              *) ENV_NAME_INPUT='development' ;;
            esac
          elif [ "$ENV_NAME_INPUT" = "dev" ]; then
            ENV_NAME_INPUT='development'
          fi

          APP_SLUG_INPUT="${{ inputs.app_slug }}"
          if [ -z "$APP_SLUG_INPUT" ]; then
            REPO_NAME_RAW="${GITHUB_REPOSITORY:-}"
            if [ -n "$REPO_NAME_RAW" ]; then
              REPO_NAME="${REPO_NAME_RAW##*/}"
            else
              REPO_NAME='app'
            fi
            APP_SLUG_INPUT=$(printf '%s' "$REPO_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
          fi

          ENV_DIR="${ENV_ROOT}/${ENV_NAME_INPUT}/${APP_SLUG_INPUT}"

          if ! mkdir -p "$ENV_DIR"; then
            echo "::error::Unable to create env directory $ENV_DIR" >&2
            exit 1
          fi

          ENV_FILE="${ENV_DIR}/.env"
          if [ ! -f "$ENV_FILE" ]; then
            {
              printf '# Generated by uactions package (remote-podman-exec).\n'
              printf '# Populate with KEY=VALUE pairs required for your deployment.\n'
            } > "$ENV_FILE"
            chown "$PODMAN_USER":"$PODMAN_USER" "$ENV_FILE" >/dev/null 2>&1 || true
            chmod 600 "$ENV_FILE" >/dev/null 2>&1 || true
          fi

          if [ "${{ inputs.source_env }}" = "true" ]; then
            if [ -z "$ENV_FILE" ]; then
              echo '::error::env_file_path must be provided when source_env=true'
              exit 1
            fi

            if [ -f "$ENV_FILE" ]; then
              set -a
              . "$ENV_FILE"
              set +a
            else
              if [ "${{ inputs.fail_if_env_missing }}" = "true" ]; then
                echo "::error::Environment file ${ENV_FILE} not found"
                echo "Environment file ${ENV_FILE} not found" >&2
                exit 1
              else
                echo "::warning::Environment file ${ENV_FILE} not found; continuing without sourcing"
              fi
            fi
          fi

          export REMOTE_ENV_FILE="$ENV_FILE"
          export REMOTE_ENV_DIR="$ENV_DIR"

          run_podman() {
            if [ "$(id -un)" = "$PODMAN_USER" ]; then
              podman "$@"
            else
              sudo -H -u "$PODMAN_USER" podman "$@"
            fi
          }

          if ! command -v podman >/dev/null 2>&1; then
            echo '::error::podman is not installed on the remote host'
            echo 'Error: podman is not installed on the remote host.' >&2
            echo 'Hint: enable host preparation in the calling action (prepare_host: true) or install podman manually.' >&2
            exit 1
          fi

          cd /

          # Begin inline script
          ${{ inputs.inline_script }}
          BASH_EOF

    - name: Skip notice (host unreachable)
      if: ${{ steps.probe.outputs.reachable != 'true' && inputs.skip_if_unreachable == 'true' }}
      shell: bash
      run: |
        echo '::notice::SSH host not reachable; skipped remote execution for this step.'
