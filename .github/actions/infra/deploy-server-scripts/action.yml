name: 'infra: deploy-server-scripts'
description: 'Bundle and deploy all server-managed scripts to $HOME/uactions/scripts on the remote host (run once before any other steps).'

inputs:
  ssh_host:
    description: 'SSH host'
    required: true
  ssh_user:
    description: 'SSH username'
    required: true
  ssh_key:
    description: 'SSH private key'
    required: true
  ssh_port:
    description: 'SSH port'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'SSH host key fingerprint'
    required: false
  probe_reachable:
    description: 'Optional reachability result (true|false) from common/ssh-probe.'
    required: false
    default: ''
  probe_attempts:
    description: 'Optional attempt count to surface in logs when probe fails.'
    required: false
    default: ''
  probe_last_error:
    description: 'Optional error message from the probe for better failure context.'
    required: false
    default: ''

# ==========================================================================
# OUTPUTS (Example usage)
# --------------------------------------------------------------------------
#   - name: Deploy shared scripts
#     id: scripts
#     uses: ./.github/actions/infra/deploy-server-scripts
#     with:
#       ssh_host: ${{ inputs.ssh_host }}
#       ssh_user: ${{ inputs.ssh_user }}
#       ssh_key: ${{ inputs.ssh_key }}
#       probe_reachable: ${{ steps.probe.outputs.reachable }}
#   - name: Skip follow-up when offline
#     if: ${{ steps.scripts.outputs.status != 'deployed' }}
#     run: echo "Server scripts unavailable"
# ==========================================================================

outputs:
  reachable:
    description: 'Normalized reachability result (defaults to true when no probe provided).'
    value: ${{ steps.summary.outputs.reachable }}
  has_bundle:
    description: 'Whether a scripts tarball was staged locally for upload.'
    value: ${{ steps.summary.outputs.has_bundle }}
  upload_status:
    description: "Outcome of the SCP upload step ('success', 'failure', or 'skipped')."
    value: ${{ steps.summary.outputs.upload_status }}
  install_status:
    description: "Outcome of the remote install step ('success', 'failure', or 'skipped')."
    value: ${{ steps.summary.outputs.install_status }}
  status:
    description: "High-level deployment status: deployed | upload_failed | install_failed | skipped_no_bundle | skipped_host_unreachable."
    value: ${{ steps.summary.outputs.status }}

runs:
  using: 'composite'
  steps:
    # Probe: We now rely on shared common/ssh-probe, so this action simply trusts probe_reachable.
    # When probe_reachable is empty, default to 'true' to maintain backwards compatibility, meaning
    # callers can omit the probe entirely if they still want the legacy behavior.
    - name: Resolve probe result
      id: reach
      shell: bash
      env:
        PROBE_REACHABLE: ${{ inputs.probe_reachable }}
        PROBE_ATTEMPTS: ${{ inputs.probe_attempts }}
        PROBE_LAST_ERROR: ${{ inputs.probe_last_error }}
      run: |
        set -euo pipefail
        reachable="${PROBE_REACHABLE:-}"
        if [ -z "$reachable" ]; then
          reachable=true
        fi
        echo "reachable=$reachable" >> "$GITHUB_OUTPUT"
        if [ "$reachable" != "true" ]; then
          attempts="${PROBE_ATTEMPTS:-unknown}"
          # Emit the last error message so users can debug without re-running the probe locally.
          printf '::notice title=Server scripts skipped::SSH probe reported unreachable after %s attempt(s).\n' "$attempts"
          if [ -n "$PROBE_LAST_ERROR" ]; then
            printf 'Last SSH error:\n%s\n' "$PROBE_LAST_ERROR"
          fi
        fi
    # Stage: Tar up the entire scripts directory into workspace cache
    - name: Stage scripts bundle
      id: stage
      if: ${{ steps.reach.outputs.reachable == 'true' }}
      shell: bash
      env:
        ACTION_PATH: ${{ github.action_path }}
        WORKSPACE: ${{ github.workspace }}
      run: |
        set -euo pipefail
        mkdir -p "$WORKSPACE/.uactions_cache"
        TAR_PATH="$WORKSPACE/.uactions_cache/uactions-scripts.tgz"
        SRC_ROOT="$(cd "$ACTION_PATH/../.." && pwd)"
        if [ ! -d "$SRC_ROOT/scripts" ]; then
          echo '::notice::No local scripts directory found; skipping server scripts upload.'
          echo "has_bundle=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi
        tar -C "$SRC_ROOT" -czf "$TAR_PATH" scripts
        # Validate archive locally before upload
        if ! tar -tzf "$TAR_PATH" >/dev/null 2>&1; then
          echo '::error::Staged tarball appears invalid or empty (tar -tzf failed). Aborting upload.'
          ls -lh "$TAR_PATH" || true
          exit 1
        fi
        ls -lh "$TAR_PATH"
        echo "has_bundle=true" >> "$GITHUB_OUTPUT"

    # Upload: Transfer tarball to remote /tmp via scp
    - name: Upload scripts bundle
      id: upload
      if: ${{ steps.reach.outputs.reachable == 'true' && steps.stage.outputs.has_bundle == 'true' }}
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ inputs.ssh_user }}
        key: ${{ inputs.ssh_key }}
        port: ${{ inputs.ssh_port }}
        source: ".uactions_cache/uactions-scripts.tgz"
        target: "~"
        overwrite: true
        strip_components: 1
        timeout: 15s
        command_timeout: 30s

    # - name: Install scripts on remote host
    #   id: install
    #   if: ${{ steps.reach.outputs.reachable != 'true' }}
    #   uses: appleboy/ssh-action@v1.0.3
    #   with:
    #     host: ${{ inputs.ssh_host }}
    #     username: ${{ inputs.ssh_user }}
    #     key: ${{ inputs.ssh_key }}
    #     port: ${{ inputs.ssh_port }}
    #     fingerprint: ${{ inputs.ssh_fingerprint }}
    #     script: |
    #       echo "Install scripts on remote host."
    #       mkdir -p "$HOME/uactions"
    #       if [ ! -f "$HOME/uactions-scripts.tgz" ]; then
    #         echo '::error::Missing $HOME/uactions-scripts.tgz on remote host (upload failed or was skipped)';
    #         exit 1
    #       fi
    #       # Validate tarball integrity to avoid 'tar: empty archive'
    #       if ! tar -tzf "$HOME/uactions-scripts.tgz" >/dev/null 2>&1; then
    #         echo '::error::Invalid or empty tar archive at $HOME/uactions-scripts.tgz (tar -tzf failed)';
    #         ls -lh "$HOME/uactions-scripts.tgz" || true
    #         exit 1
    #       fi
    #       # Replace scripts atomically
    #       TMPDIR="$(mktemp -d)"
    #       tar -xzf "$HOME/uactions-scripts.tgz" -C "$TMPDIR"
    #       rm -rf "$HOME/uactions/scripts"
    #       mv "$TMPDIR/scripts" "$HOME/uactions/scripts"
    #       rm -rf "$TMPDIR"
    #       # Ensure all scripts are executable
    #       find "$HOME/uactions/scripts" -type f -name '*.sh' -exec chmod +x {} +
    #       # Stamp version marker for visibility
    #       date -u +'%Y-%m-%d %H:%M:%S UTC' > "$HOME/uactions/scripts/.deployed_at"
    #       echo '${{ github.sha }}' > "$HOME/uactions/scripts/.version"


    # Summarize: Normalize outcomes into reusable outputs for callers.
    - name: Record deployment status
      id: summary
      if: ${{ always() }}
      shell: bash
      env:
        PROBE_REACHABLE: ${{ inputs.probe_reachable }}
        REACHABLE: ${{ steps.reach.outputs.reachable }}
        HAS_BUNDLE: ${{ steps.stage.outputs.has_bundle }}
        UPLOAD_OUTCOME: ${{ steps.upload.outcome }}
        INSTALL_OUTCOME: ${{ steps.install.outcome }}
      run: |
        set -euo pipefail

        reachable="${REACHABLE:-${PROBE_REACHABLE:-}}"
        if [ -z "$reachable" ]; then
          reachable=true
        fi

        has_bundle="${HAS_BUNDLE:-false}"
        if [ -z "$has_bundle" ]; then
          has_bundle=false
        fi

        upload_status="${UPLOAD_OUTCOME:-skipped}"
        install_status="${INSTALL_OUTCOME:-skipped}"

        status="skipped_host_unreachable"
        if [ "$reachable" = "true" ]; then
          status="skipped_no_bundle"
          if [ "$has_bundle" = "true" ]; then
            status="upload_failed"
            if [ "$upload_status" = "success" ]; then
              status="install_failed"
              if [ "$install_status" = "success" ]; then
                status="deployed"
              fi
            fi
          fi
        fi

        {
          printf 'reachable=%s\n' "$reachable"
          printf 'has_bundle=%s\n' "$has_bundle"
          printf 'upload_status=%s\n' "$upload_status"
          printf 'install_status=%s\n' "$install_status"
          printf 'status=%s\n' "$status"
        } >> "$GITHUB_OUTPUT"

    - name: Fail when host unreachable
      if: ${{ steps.reach.outputs.reachable != 'true' }}
      shell: bash
      env:
        PROBE_ATTEMPTS: ${{ inputs.probe_attempts }}
        PROBE_LAST_ERROR: ${{ inputs.probe_last_error }}
        SUMMARY_STATUS: ${{ steps.summary.outputs.status }}
      run: |
        set -euo pipefail
        echo "::error title=Server scripts deployment blocked::SSH probe reported the host as unreachable, so infra/deploy-server-scripts cannot continue."
        if [ -n "$PROBE_ATTEMPTS" ]; then
          echo "::error::Probe attempts: $PROBE_ATTEMPTS"
        fi
        if [ -n "$PROBE_LAST_ERROR" ]; then
          printf '::error::Last SSH error message::\n%s\n' "$PROBE_LAST_ERROR"
        fi
        if [ -n "$SUMMARY_STATUS" ]; then
          echo "::error::Recorded status: $SUMMARY_STATUS"
        fi
        echo '::error::Unable to prepare host with managed scripts due to unreachable SSH host.'
        exit 1
