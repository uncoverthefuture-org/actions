# ============================================================================
# ACTION: Prepare Ubuntu Host
# ============================================================================
# PURPOSE:
# Bootstraps a fresh Ubuntu server for containerized deployments.
# Installs Podman, Traefik, creates directories, and configures firewall.
#
# WHAT IT DOES:
# 1. Validates all required inputs
# 2. Installs Podman (container runtime)
# 3. Creates deployment directories owned by ssh_user
# 4. Installs Traefik (optional)
# 5. Configures firewall and optional services
# 6. Configures UFW firewall
# 7. Installs additional packages
#
# WHEN TO USE:
# - First deployment to a new Ubuntu server
# - Setting up a fresh server for containerized applications
# - Preparing infrastructure for CI/CD deployments
#
# REQUIREMENTS:
# - Fresh Ubuntu 20.04+ server
# - SSH access as root or user with sudo
# - Internet access for package installation
#
# REFERENCE: See docs/GETTING_STARTED.md Step 1 and docs/ACTION_FILES_GUIDE.md
# ============================================================================

name: 'Prepare Ubuntu Host'
description: 'Bootstraps a fresh Ubuntu server for containerized deployments (Podman, directories, optional user).'

# ============================================================================
# INPUTS - Organized by category
# ============================================================================
inputs:
  # ========================================================================
  # SSH / REMOTE EXECUTION
  # ========================================================================
  # Parameters for SSH connection to the remote server
  ssh_host:
    description: 'SSH host (IP or hostname). Required. Example: 192.168.1.100 or deploy.example.com'
    required: true
  ssh_user:
    description: 'SSH username (non-root). Required. Used for authentication and privilege escalation'
    required: true
  ssh_key:
    description: 'SSH private key for authentication. Required. Should be stored as GitHub secret'
    required: true
  ssh_port:
    description: 'SSH port. Default: 22. Change if using non-standard SSH port'
    required: false
    default: '22'
  ssh_fingerprint:
    description: 'Server SSH host key fingerprint for verification. Optional but recommended for security'
    required: false
  root_ssh_key:
    description: 'Root SSH private key (optional, forwarded from callers; not used directly)'
    required: false
    default: ''
  connect_mode:
    description: "Connection mode: auto|root|user (forwarded to sub-steps where applicable)"
    required: false
    default: 'user'

  # ========================================================================
  # PODMAN CONFIGURATION
  # ========================================================================
  # Parameters for Podman container runtime setup
  install_podman:
    description: 'Install Podman and dependencies. Default: true. Set false if already installed'
    required: false
    default: 'true'
  create_podman_user:
    description: 'Create a dedicated podman user if missing (forwarded input)'
    required: false
    default: 'false'
  podman_user:
    description: 'Podman user on remote host (forwarded input)'
    required: false
    default: ''

  # ========================================================================
  # DIRECTORY CONFIGURATION
  # ========================================================================
  # Parameters for deployment directory structure
  env_dir_path:
    description: 'Directory to hold env files and app data. Default: /var/deployments. Example: /opt/apps'
    required: false

  # ========================================================================
  # PACKAGE INSTALLATION
  # ========================================================================
  # Parameters for additional packages to install
  additional_packages:
    description: 'Space-separated additional apt packages to install. Default: jq curl ca-certificates. Example: git vim htop'
    required: false
    default: 'jq curl ca-certificates'

  # ========================================================================
  # OPTIONAL PLATFORM SERVICES
  # ========================================================================
  # Parameters for optional services (Apache, Webmin, etc.)
  install_apache:
    description: 'Install and configure Apache2 with common modules. Default: false. Deprecated in favor of Traefik'
    required: false
    default: 'false'
  install_webmin:
    description: 'Install Webmin (web-based system administration). Default: false'
    required: false
    default: 'false'
  install_usermin:
    description: 'Install Usermin (user-level web administration). Default: false'
    required: false
    default: 'false'

  # ========================================================================
  # FIREWALL CONFIGURATION
  # ========================================================================
  # Parameters for UFW firewall setup
  configure_ufw:
    description: 'Configure UFW firewall. Default: true. Set false to skip firewall configuration'
    required: false
    default: 'true'
  ufw_allow_ports:
    description: 'Space-separated list of TCP ports to allow. Default: 22 80 443 10000 20000. Example: 22 80 443 3000'
    required: false
    default: '22 80 443 10000 20000'

  # ========================================================================
  # TRAEFIK CONFIGURATION
  # ========================================================================
  # Parameters for Traefik reverse proxy with automatic HTTPS
  install_traefik:
    description: 'Install and run Traefik as reverse proxy with SSL. Default: true. Provides automatic HTTPS with Let''s Encrypt'
    required: false
    default: 'true'
  traefik_email:
    description: "Email for Let's Encrypt certificates. Required if install_traefik=true. Example: admin@example.com"
    required: false
    default: ''
  traefik_enable_acme:
    description: "Enable ACME/Let's Encrypt in Traefik during setup (default: false)"
    required: false
    default: 'false'
  debug:
    description: 'Enable verbose logging in nested remote steps (paths, user info). Default: false'
    required: false
    default: 'false'
  show_root_install_hints:
    description: 'Show explicit manual install instructions when root privileges are required (fail-fast messaging)'
    required: false
    default: 'true'

# ============================================================================
# EXECUTION STEPS
# ============================================================================
# The preparation follows these steps:
# 1. Validate inputs - Check required parameters
# 2. Compute defaults - Calculate derived values
# 3. Install Podman - Container runtime (optional)
# 4. Ensure deployment directories exist with ssh_user ownership
# 5. Install Traefik - Reverse proxy (optional)
# 6. Configure firewall / optional services
# 7. Install packages - Additional utilities
#
# REFERENCE: See docs/ACTION_FILES_GUIDE.md for detailed step explanations
# ============================================================================

runs:
  using: 'composite'
  steps:
    # ========================================================================
    # STEP 1: Validate inputs
    # ========================================================================
    # Checks that all required parameters are provided and valid
    # Fails early if configuration is incorrect
    # ========================================================================
    - name: Validate inputs
      run: |
        if [ -z "${{ inputs.ssh_host }}" ]; then echo 'Error: ssh_host is required' ; exit 1 ; fi
        if [ -z "${{ inputs.ssh_user }}" ]; then echo 'Error: ssh_user is required' ; exit 1 ; fi
        if [ -z "${{ inputs.ssh_key }}" ]; then echo 'Error: ssh_key is required' ; exit 1 ; fi
        if [ "${{ inputs.install_traefik }}" = "true" ] && [ "${{ inputs.traefik_enable_acme }}" = "true" ] && [ -z "${{ inputs.traefik_email }}" ]; then
          echo 'Error: traefik_email is required when install_traefik=true and traefik_enable_acme=true'
          exit 1
        fi
        case "${{ inputs.install_podman }}" in true|false) :;; *) echo 'Error: install_podman must be true or false' ; exit 1 ;;
        esac
        if [ "${{ inputs.ssh_user }}" != "root" ]; then
          echo '::notice::ssh_user is not root; ensure this user already has required privileges. Host preparation must be executed with an account that can install packages and configure services.'
        fi
      shell: bash

    - name: Compute repo defaults
      id: defaults
      uses: ./.github/actions/app/common/compute-defaults

    - name: Probe host capabilities
      id: probe
      uses: ./.github/actions/infra/probe-host-capabilities
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}

    - name: Fail fast if Podman missing and cannot escalate
      if: ${{ inputs.install_podman == 'true' && steps.probe.outputs.has_podman != 'true' }}
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ inputs.ssh_host }}
        username: ${{ inputs.ssh_user }}
        key: ${{ inputs.ssh_key }}
        port: ${{ inputs.ssh_port }}
        fingerprint: ${{ inputs.ssh_fingerprint }}
        script: |
          set -euo pipefail
          # If already root or sudo -n works, proceed (install step will run next)
          if [ "$(id -u)" -eq 0 ]; then exit 0; fi
          if command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then exit 0; fi
          # Otherwise, fail fast with explicit instructions
          if [ '${{ inputs.show_root_install_hints }}' = 'true' ]; then
            echo '::error::Podman is not installed and the current user cannot escalate privileges for package installation.' >&2
            echo "Detected: user=$(id -un); sudo(non-interactive)=no" >&2
            echo 'Install manually on the server (as root), then re-run:' >&2
            echo '  sudo apt-get update -y' >&2
            echo '  sudo apt-get install -y podman curl jq ca-certificates' >&2
            echo 'Alternatively, re-run this action with connect_mode: root or provide root_ssh_key.' >&2
          else
            echo '::error::Root privileges required to install Podman.' >&2
          fi
          exit 1

    - name: Install Podman
      if: ${{ inputs.install_podman == 'true' && steps.probe.outputs.has_podman != 'true' }}
      uses: ./.github/actions/infra/install-podman
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        additional_packages: ${{ inputs.additional_packages }}
        show_root_install_hints: ${{ inputs.show_root_install_hints }}

    - name: Ensure deployment directories
      uses: ./.github/actions/podman/remote-podman-exec
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        connect_mode: ${{ inputs.connect_mode }}
        debug: ${{ inputs.debug }}
        inline_script: |
          set -euo pipefail
          # Normalize target deployment directory on the REMOTE host:
          # - Prefer the remote user's $HOME (never the GitHub runner's /home/runner)
          # - Expand ~ to $HOME
          # - Rebase any /home/runner/... path segments to $HOME/...
          # - Default to $HOME/deployments/<env>/<app> when not provided
          ENV_NAME_DEFAULT='${{ steps.defaults.outputs.env_name_default }}'
          APP_SLUG='${{ steps.defaults.outputs.app_slug }}'
          TARGET_IN='${{ inputs.env_dir_path != '' && inputs.env_dir_path || steps.defaults.outputs.env_dir_path }}'
          if [ -z "$TARGET_IN" ]; then
            TARGET_DIR="$HOME/deployments/${ENV_NAME_DEFAULT}/${APP_SLUG}"
          else
            # Expand ~ and rebase /home/runner to $HOME for safe, user-owned paths
            case "$TARGET_IN" in
              "~/"*)
                TARGET_DIR="$HOME/${TARGET_IN#~/}"
                ;;
              "/home/runner/"*)
                TARGET_DIR="$HOME/${TARGET_IN#/home/runner/}"
                ;;
              *)
                TARGET_DIR="$TARGET_IN"
                ;;
            esac
          fi
          if [ "${DEBUG:-false}" = "true" ]; then
            echo "ðŸ“ Ensuring deployment directory exists: ${TARGET_DIR} (user=$(id -un))"
          else
            echo "ðŸ“ Ensuring deployment directory exists"
          fi
          if [ -z "$TARGET_DIR" ]; then
            echo '::error::Unable to resolve target directory for environment files.' >&2
            exit 1
          fi
          # Create target dir; if blocked, escalate once with sudo and fix ownership
          if [ ! -d "$TARGET_DIR" ]; then
            if ! mkdir -p "$TARGET_DIR" 2>/dev/null; then
              if command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then
                sudo mkdir -p "$TARGET_DIR" 2>/dev/null || true
                sudo chown -R "$(id -un):$(id -gn)" "$TARGET_DIR" 2>/dev/null || true
              else
                echo "::error::Unable to create environment directory" >&2
                echo "Hint: ensure the SSH user owns the parent directory or use a user-writable location." >&2
                exit 1
              fi
            fi
            if [ "${DEBUG:-false}" = "true" ]; then
              echo "âœ… Created directory $TARGET_DIR"
            else
              echo "âœ… Created directory"
            fi
          fi
          # If still not writable, attempt to fix ownership once with sudo
          if [ ! -w "$TARGET_DIR" ]; then
            if command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then
              sudo chown -R "$(id -un):$(id -gn)" "$TARGET_DIR" 2>/dev/null || true
            fi
          fi
          if [ ! -w "$TARGET_DIR" ]; then
            echo "::error::Directory $TARGET_DIR is not writable by $(id -un). Adjust ownership or choose a user-owned path." >&2
            exit 1
          fi

    - name: Install Apache
      if: ${{ inputs.install_apache == 'true' && steps.probe.outputs.has_apache != 'true' }}
      uses: ./.github/actions/infra/install-apache
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}

    - name: Install Webmin/Usermin
      if: ${{ (inputs.install_webmin == 'true' && steps.probe.outputs.has_webmin != 'true') || (inputs.install_usermin == 'true' && steps.probe.outputs.has_usermin != 'true') }}
      uses: ./.github/actions/infra/install-webmin
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        install_webmin: ${{ inputs.install_webmin }}
        install_usermin: ${{ inputs.install_usermin }}

    # NOTE: We intentionally run UFW configuration unconditionally (when enabled)
    # because $GITHUB_OUTPUT is NOT available on the REMOTE host. Attempting to
    # write to it from a remote inline_script (via remote-podman-exec) caused
    # 'GITHUB_OUTPUT: unbound variable'. The configure-ufw script is idempotent
    # and safe to re-run; it only applies missing rules and enables UFW if inactive.
    # This avoids remote-output plumbing and prevents failures under 'set -u'.
    - name: Configure UFW
      if: ${{ inputs.configure_ufw == 'true' }}
      uses: ./.github/actions/infra/configure-ufw
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        # If the caller omits ufw_allow_ports, default to allowing 22,80,443
        # to ensure HTTP/HTTPS reachability on fresh servers.
        ufw_allow_ports: ${{ inputs.ufw_allow_ports != '' && inputs.ufw_allow_ports || '22 80 443' }}
        enable_podman_forward: 'true'
        route_ports: '80 443'
        set_forward_policy_accept: 'true'
        wan_iface: ''
        podman_iface: ''

    - name: Setup Traefik reverse proxy
      if: ${{ inputs.install_traefik == 'true' }}
      uses: ./.github/actions/infra/setup-traefik
      with:
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
        traefik_email: ${{ inputs.traefik_email }}
        enable_acme: ${{ inputs.traefik_enable_acme }}
