# ============================================================================
# ACTION: Infrastructure Dispatcher
# ============================================================================
# PURPOSE:
# Internal router that dispatches to infrastructure setup and management actions.
# Routes infrastructure requests to appropriate handlers.
#
# WHAT IT DOES:
# 1. Receives subaction name and parameters
# 2. Routes to appropriate infra action (prepare-host, manage-vhost, etc.)
# 3. Passes all parameters to the selected action
# 4. Returns outputs from the selected action
#
# WHEN TO USE:
# - Internal action used by main aggregator
# - Routes infrastructure setup and management requests
# - Part of the aggregator pattern
#
# SUPPORTED SUBACTIONS:
# - prepare-ubuntu-host: Full server preparation
# - apache-manage-vhost: Manage Apache virtual hosts
# - install-podman, install-apache, install-webmin, install-certbot
# - configure-ufw: Firewall configuration
# - And more infrastructure utilities
#
# REFERENCE: See docs/ARCHITECTURE.md for dispatcher pattern explanation
# ============================================================================

name: 'dispatch: infra'
description: 'Infra dispatch: route short calls to infra actions'

# ============================================================================
# INPUTS - Pass-through parameters
# ============================================================================
# All inputs are passed through to the selected subaction
# ============================================================================
inputs:
  # ========================================================================
  # ROUTING
  # ========================================================================
  subaction:
    description: "Subaction to route to. Required. Options: prepare-ubuntu-host, apache-manage-vhost, install-podman, install-apache, install-webmin, install-certbot, configure-ufw, and more"
    required: true
  params_json:
    description: "JSON blob of parameters to pass to the selected subaction. Optional. Used for complex parameter passing"
    required: false

  # --- Remote connection (common) ---
  ssh_host:
    required: false
  ssh_user:
    required: false
  ssh_key:
    required: false
  root_ssh_key:
    required: false
  ssh_port:
    required: false
    default: '22'
  ssh_fingerprint:
    required: false

  # --- Host preparation toggles ---
  env_dir_path:
    required: false
  install_podman:
    required: false
    default: 'true'
  additional_packages:
    required: false
    default: 'jq curl ca-certificates'
  install_apache:
    required: false
    default: 'false'
  install_webmin:
    required: false
    default: 'true'
  install_certbot:
    required: false
    default: 'false'
  install_usermin:
    required: false
    default: 'true'
  configure_ufw:
    required: false
    default: 'true'
  ufw_allow_ports:
    required: false
    default: '22 80 443 10000 20000'

  # --- VHost & domain derivation ---
  domain:
    required: false
  base_domain:
    required: false
  env_name:
    required: false
  env_file_path:
    required: false
  source_env:
    required: false
    default: 'false'
  fail_if_env_missing:
    required: false
    default: 'true'
  host_port:
    required: false
  vhost_mode:
    required: false
    default: 'mod_wsgi'
  wsgi_script_path:
    required: false
  server_admin:
    required: false
    default: 'webmaster@localhost'
  require_dns_match:
    required: false
    default: 'true'
  domain_prefix_prod:
    required: false
    default: ''
  domain_prefix_staging:
    required: false
    default: 'staging'
  domain_prefix_dev:
    required: false
    default: 'dev'

  # --- Certbot options ---
  certbot_email:
    required: false
  certbot_extra_domains:
    required: false
  certbot_staging:
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Normalize params JSON
      id: pjson
      env:
        INPUT_PARAMS_JSON: ${{ inputs.params_json }}
      run: |
        set -euo pipefail
        J="${INPUT_PARAMS_JSON}"
        if [ -z "$J" ]; then J='{}'; fi
        echo "json=$J" >> "$GITHUB_OUTPUT"
      shell: bash
    - name: Compute repo defaults
      id: defaults
      uses: ./.github/actions/app/common/compute-defaults
    - name: Resolve remote inputs
      id: remote
      uses: ./.github/actions/infra/common/resolve-remote
      with:
        params_json: ${{ steps.pjson.outputs.json }}
        ssh_host: ${{ inputs.ssh_host }}
        ssh_user: ${{ inputs.ssh_user }}
        ssh_key: ${{ inputs.ssh_key }}
        root_ssh_key: ${{ inputs.root_ssh_key }}
        ssh_port: ${{ inputs.ssh_port }}
        ssh_fingerprint: ${{ inputs.ssh_fingerprint }}
    - name: Validate infra subaction
      run: |
        set -euo pipefail
        SA='${{ inputs.subaction }}'
        case "$SA" in prepare-ubuntu-host|apache-manage-vhost|install-podman|install-apache|install-webmin|install-certbot|request-certbot-cert|ensure-certbot-cert|configure-ufw|determine-domain|compute-host-port|check-dns-match|ensure-apache-installed|enable-apache-modules|manage-vhost-config|enable-site-reload|diagnose-routing|setup-traefik) :;; *) echo "::error::Unsupported infra subaction '$SA'"; echo "Error: unsupported infra subaction '$SA'" >&2; exit 1;; esac
      shell: bash

    - name: Validate base SSH for infra subactions
      env:
        SA: ${{ inputs.subaction }}
        SSH_HOST: ${{ steps.remote.outputs.ssh_host }}
        SSH_USER: ${{ steps.remote.outputs.ssh_user }}
        SSH_KEY: ${{ steps.remote.outputs.ssh_key }}
      run: |
        set -euo pipefail
        case "$SA" in
          prepare-ubuntu-host|apache-manage-vhost|install-podman|install-apache|install-webmin|install-certbot|request-certbot-cert|ensure-certbot-cert|configure-ufw|compute-host-port)
            for var in SSH_HOST SSH_USER SSH_KEY; do
              val="${!var}"
              if [ -z "$val" ]; then
                echo "::error::${var,,} is required for $SA"
                echo "Error: ${var,,} is required for $SA" >&2
                exit 1
              fi
            done
            ;;
          diagnose-routing)
            for var in SSH_HOST SSH_USER SSH_KEY; do
              val="${!var}"
              if [ -z "$val" ]; then
                echo "::error::${var,,} is required for $SA"
                echo "Error: ${var,,} is required for $SA" >&2
                exit 1
              fi
            done
            ;;
          setup-traefik)
            for var in SSH_HOST SSH_USER SSH_KEY; do
              val="${!var}"
              if [ -z "$val" ]; then
                echo "::error::${var,,} is required for $SA"
                echo "Error: ${var,,} is required for $SA" >&2
                exit 1
              fi
            done
            ;;
        esac
      shell: bash

    - name: Run host subaction
      if: ${{ inputs.subaction == 'prepare-ubuntu-host' || inputs.subaction == 'install-podman' || inputs.subaction == 'install-apache' || inputs.subaction == 'install-webmin' || inputs.subaction == 'configure-ufw' }}
      uses: ./.github/actions/infra/host
      with:
        params_json: ${{ inputs.params_json }}
        subaction: ${{ inputs.subaction }}
        ssh_host: ${{ steps.remote.outputs.ssh_host }}
        ssh_user: ${{ steps.remote.outputs.ssh_user }}
        ssh_key: ${{ steps.remote.outputs.ssh_key }}
        root_ssh_key: ${{ steps.remote.outputs.root_ssh_key }}
        ssh_port: ${{ steps.remote.outputs.ssh_port }}
        ssh_fingerprint: ${{ steps.remote.outputs.ssh_fingerprint }}
        env_dir_path: ${{ inputs.env_dir_path }}
        install_podman: ${{ inputs.install_podman }}
        additional_packages: ${{ inputs.additional_packages }}
        install_apache: ${{ inputs.install_apache }}
        install_webmin: ${{ inputs.install_webmin }}
        install_certbot: ${{ inputs.install_certbot }}
        install_usermin: ${{ inputs.install_usermin }}
        configure_ufw: ${{ inputs.configure_ufw }}
        ufw_allow_ports: ${{ inputs.ufw_allow_ports }}

    - name: Run vhost subaction
      if: ${{ inputs.subaction == 'apache-manage-vhost' || inputs.subaction == 'determine-domain' || inputs.subaction == 'compute-host-port' || inputs.subaction == 'check-dns-match' || inputs.subaction == 'ensure-apache-installed' || inputs.subaction == 'enable-apache-modules' || inputs.subaction == 'manage-vhost-config' || inputs.subaction == 'enable-site-reload' }}
      uses: ./.github/actions/infra/vhost
      with:
        params_json: ${{ inputs.params_json }}
        subaction: ${{ inputs.subaction }}
        ssh_host: ${{ steps.remote.outputs.ssh_host }}
        ssh_user: ${{ steps.remote.outputs.ssh_user }}
        ssh_key: ${{ steps.remote.outputs.ssh_key }}
        root_ssh_key: ${{ steps.remote.outputs.root_ssh_key }}
        ssh_port: ${{ steps.remote.outputs.ssh_port }}
        ssh_fingerprint: ${{ steps.remote.outputs.ssh_fingerprint }}
        domain: ${{ inputs.domain }}
        base_domain: ${{ inputs.base_domain }}
        env_name: ${{ inputs.env_name }}
        env_file_path: ${{ inputs.env_file_path }}
        source_env: ${{ inputs.source_env }}
        fail_if_env_missing: ${{ inputs.fail_if_env_missing }}
        host_port: ${{ inputs.host_port }}
        vhost_mode: ${{ inputs.vhost_mode }}
        wsgi_script_path: ${{ inputs.wsgi_script_path }}
        server_admin: ${{ inputs.server_admin }}
        require_dns_match: ${{ inputs.require_dns_match }}
        domain_prefix_prod: ${{ inputs.domain_prefix_prod }}
        domain_prefix_staging: ${{ inputs.domain_prefix_staging }}
        domain_prefix_dev: ${{ inputs.domain_prefix_dev }}

    - name: Run certbot subaction
      if: ${{ inputs.subaction == 'install-certbot' || inputs.subaction == 'request-certbot-cert' || inputs.subaction == 'ensure-certbot-cert' }}
      uses: ./.github/actions/infra/certbot
      with:
        params_json: ${{ inputs.params_json }}
        subaction: ${{ inputs.subaction }}
        ssh_host: ${{ steps.remote.outputs.ssh_host }}
        ssh_user: ${{ steps.remote.outputs.ssh_user }}
        ssh_key: ${{ steps.remote.outputs.ssh_key }}
        root_ssh_key: ${{ steps.remote.outputs.root_ssh_key }}
        ssh_port: ${{ steps.remote.outputs.ssh_port }}
        ssh_fingerprint: ${{ steps.remote.outputs.ssh_fingerprint }}
        domain: ${{ inputs.domain }}
        certbot_email: ${{ inputs.certbot_email }}
        certbot_extra_domains: ${{ inputs.certbot_extra_domains }}
        certbot_staging: ${{ inputs.certbot_staging }}

    - name: Extract setup-traefik params
      if: ${{ inputs.subaction == 'setup-traefik' }}
      id: trafparams
      shell: bash
      env:
        J: ${{ steps.pjson.outputs.json }}
      run: |
        set -euo pipefail
        get() { printf '%s' "$J" | jq -r "$1 // empty" 2>/dev/null || true; }
        traefik_email=$(get '.traefik_email')
        traefik_version=$(get '.traefik_version')
        enable_acme=$(get '.enable_acme')
        enable_ping=$(get '.enable_ping')
        use_host_network=$(get '.use_host_network')
        network_name=$(get '.network_name')
        enable_metrics=$(get '.enable_metrics')
        metrics_entrypoint=$(get '.metrics_entrypoint')
        metrics_address=$(get '.metrics_address')
        acme_dns_provider=$(get '.acme_dns_provider')
        acme_dns_resolvers=$(get '.acme_dns_resolvers')
        enable_dashboard=$(get '.enable_dashboard')
        mode=$(get '.mode')
        quadlet_enable_http3=$(get '.quadlet_enable_http3')
        dashboard_user=$(get '.dashboard_user')
        dashboard_password_bcrypt=$(get '.dashboard_password_bcrypt')
        dashboard_publish_modes=$(get '.dashboard_publish_modes')
        dashboard_host=$(get '.dashboard_host')
        dashboard_password=$(get '.dashboard_password')
        dashboard_users_b64=$(get '.dashboard_users_b64')
        skip_upload=$(get '.skip_upload')
        {
          echo "traefik_email=${traefik_email}"
          echo "traefik_version=${traefik_version}"
          echo "enable_acme=${enable_acme}"
          echo "enable_ping=${enable_ping}"
          echo "use_host_network=${use_host_network}"
          echo "network_name=${network_name}"
          echo "enable_metrics=${enable_metrics}"
          echo "metrics_entrypoint=${metrics_entrypoint}"
          echo "metrics_address=${metrics_address}"
          echo "acme_dns_provider=${acme_dns_provider}"
          echo "acme_dns_resolvers=${acme_dns_resolvers}"
          echo "enable_dashboard=${enable_dashboard}"
          echo "mode=${mode}"
          echo "quadlet_enable_http3=${quadlet_enable_http3}"
          echo "dashboard_user=${dashboard_user}"
          echo "dashboard_password_bcrypt=${dashboard_password_bcrypt}"
          echo "dashboard_publish_modes=${dashboard_publish_modes}"
          echo "dashboard_host=${dashboard_host}"
          echo "dashboard_password=${dashboard_password}"
          echo "dashboard_users_b64=${dashboard_users_b64}"
          echo "skip_upload=${skip_upload}"
        } >> "$GITHUB_OUTPUT"

    - name: Run setup-traefik subaction
      if: ${{ inputs.subaction == 'setup-traefik' }}
      uses: ./.github/actions/infra/setup-traefik
      with:
        ssh_host: ${{ steps.remote.outputs.ssh_host }}
        ssh_user: ${{ steps.remote.outputs.ssh_user }}
        ssh_key: ${{ steps.remote.outputs.ssh_key }}
        ssh_port: ${{ steps.remote.outputs.ssh_port }}
        ssh_fingerprint: ${{ steps.remote.outputs.ssh_fingerprint }}
        traefik_email: ${{ steps.trafparams.outputs.traefik_email }}
        traefik_version: ${{ steps.trafparams.outputs.traefik_version || 'v3.5.4' }}
        enable_acme: ${{ steps.trafparams.outputs.enable_acme || 'true' }}
        enable_ping: ${{ steps.trafparams.outputs.enable_ping || 'true' }}
        use_host_network: ${{ steps.trafparams.outputs.use_host_network || 'false' }}
        network_name: ${{ steps.trafparams.outputs.network_name || 'traefik-network' }}
        enable_metrics: ${{ steps.trafparams.outputs.enable_metrics || 'false' }}
        metrics_entrypoint: ${{ steps.trafparams.outputs.metrics_entrypoint || 'metrics' }}
        metrics_address: ${{ steps.trafparams.outputs.metrics_address || ':8082' }}
        acme_dns_provider: ${{ steps.trafparams.outputs.acme_dns_provider }}
        acme_dns_resolvers: ${{ steps.trafparams.outputs.acme_dns_resolvers }}
        enable_dashboard: ${{ steps.trafparams.outputs.enable_dashboard || 'false' }}
        mode: ${{ steps.trafparams.outputs.mode || 'container' }}
        quadlet_enable_http3: ${{ steps.trafparams.outputs.quadlet_enable_http3 || 'false' }}
        dashboard_user: ${{ steps.trafparams.outputs.dashboard_user }}
        dashboard_password_bcrypt: ${{ steps.trafparams.outputs.dashboard_password_bcrypt }}
        dashboard_publish_modes: ${{ steps.trafparams.outputs.dashboard_publish_modes }}
        dashboard_host: ${{ steps.trafparams.outputs.dashboard_host }}
        dashboard_password: ${{ steps.trafparams.outputs.dashboard_password }}
        dashboard_users_b64: ${{ steps.trafparams.outputs.dashboard_users_b64 }}
        skip_upload: ${{ steps.trafparams.outputs.skip_upload || 'true' }}

    - name: Extract diagnose-routing params
      if: ${{ inputs.subaction == 'diagnose-routing' }}
      id: diagparams
      shell: bash
      env:
        J: ${{ steps.pjson.outputs.json }}
      run: |
        set -euo pipefail
        get() { printf '%s' "$J" | jq -r "$1 // empty" 2>/dev/null || true; }
        domain_effective=$(get '.domain_effective')
        container_name=$(get '.container_name')
        traefik_container=$(get '.traefik_container')
        host_port=$(get '.host_port')
        container_port=$(get '.container_port')
        skip_upload=$(get '.skip_upload')
        fail_on_issues=$(get '.fail_on_issues')
        attempt_auto_fix=$(get '.attempt_auto_fix')
        enable_traefik=$(get '.enable_traefik')
        traefik_network_name=$(get '.traefik_network_name')
        traefik_email=$(get '.traefik_email')
        {
          echo "domain_effective=${domain_effective}"
          echo "container_name=${container_name}"
          echo "traefik_container=${traefik_container}"
          echo "host_port=${host_port}"
          echo "container_port=${container_port}"
          echo "skip_upload=${skip_upload}"
          echo "fail_on_issues=${fail_on_issues}"
          echo "attempt_auto_fix=${attempt_auto_fix}"
          echo "enable_traefik=${enable_traefik}"
          echo "traefik_network_name=${traefik_network_name}"
          echo "traefik_email=${traefik_email}"
        } >> "$GITHUB_OUTPUT"

    - name: Run diagnose-routing subaction
      if: ${{ inputs.subaction == 'diagnose-routing' }}
      uses: ./.github/actions/infra/diagnose-routing
      with:
        ssh_host: ${{ steps.remote.outputs.ssh_host }}
        ssh_user: ${{ steps.remote.outputs.ssh_user }}
        ssh_key: ${{ steps.remote.outputs.ssh_key }}
        root_ssh_key: ${{ steps.remote.outputs.root_ssh_key }}
        ssh_port: ${{ steps.remote.outputs.ssh_port }}
        ssh_fingerprint: ${{ steps.remote.outputs.ssh_fingerprint }}
        app_slug: ${{ steps.defaults.outputs.app_slug }}
        env_name: ${{ steps.defaults.outputs.env_name_default }}
        container_name: ${{ steps.diagparams.outputs.container_name }}
        domain_effective: ${{ steps.diagparams.outputs.domain_effective }}
        traefik_container: ${{ steps.diagparams.outputs.traefik_container }}
        host_port: ${{ steps.diagparams.outputs.host_port }}
        container_port: ${{ steps.diagparams.outputs.container_port }}
        skip_upload: ${{ steps.diagparams.outputs.skip_upload || 'false' }}
        fail_on_issues: ${{ steps.diagparams.outputs.fail_on_issues || 'true' }}
        attempt_auto_fix: ${{ steps.diagparams.outputs.attempt_auto_fix || 'true' }}
        enable_traefik: ${{ steps.diagparams.outputs.enable_traefik || 'true' }}
        traefik_network_name: ${{ steps.diagparams.outputs.traefik_network_name || 'traefik-network' }}
        traefik_email: ${{ steps.diagparams.outputs.traefik_email }}